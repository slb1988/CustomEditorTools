// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STORY_FB_H_
#define FLATBUFFERS_GENERATED_STORY_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct Story;
struct StoryBuilder;
struct StoryT;

struct StoryRow;
struct StoryRowBuilder;
struct StoryRowT;

struct StoryT : public ::flatbuffers::NativeTable {
  typedef Story TableType;
  std::vector<std::unique_ptr<fb::StoryRowT>> Storys{};
  StoryT() = default;
  StoryT(const StoryT &o);
  StoryT(StoryT&&) FLATBUFFERS_NOEXCEPT = default;
  StoryT &operator=(StoryT o) FLATBUFFERS_NOEXCEPT;
};

struct Story FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StoryT NativeTableType;
  typedef StoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORYS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::StoryRow>> *Storys() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::StoryRow>> *>(VT_STORYS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STORYS) &&
           verifier.VerifyVector(Storys()) &&
           verifier.VerifyVectorOfTables(Storys()) &&
           verifier.EndTable();
  }
  StoryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Story> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoryBuilder {
  typedef Story Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Storys(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::StoryRow>>> Storys) {
    fbb_.AddOffset(Story::VT_STORYS, Storys);
  }
  explicit StoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Story> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Story>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Story> CreateStory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::StoryRow>>> Storys = 0) {
  StoryBuilder builder_(_fbb);
  builder_.add_Storys(Storys);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Story> CreateStoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<fb::StoryRow>> *Storys = nullptr) {
  auto Storys__ = Storys ? _fbb.CreateVectorOfSortedTables<fb::StoryRow>(Storys) : 0;
  return fb::CreateStory(
      _fbb,
      Storys__);
}

::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StoryRowT : public ::flatbuffers::NativeTable {
  typedef StoryRow TableType;
  uint32_t uid = 0;
  int32_t StoryId = 0;
  uint32_t GroupId = 0;
  uint32_t TalkerRoboId = 0;
  int32_t TextUI = 0;
  bool CloseUIWhenFinish = false;
  std::string TextContent{};
  fb::TextDisplayType TextDisplayType = fb::TextDisplayType_NONE;
  int32_t TextSpeed = 0;
  int32_t DelayTime = 0;
};

struct StoryRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StoryRowT NativeTableType;
  typedef StoryRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UID = 4,
    VT_STORYID = 6,
    VT_GROUPID = 8,
    VT_TALKERROBOID = 10,
    VT_TEXTUI = 12,
    VT_CLOSEUIWHENFINISH = 14,
    VT_TEXTCONTENT = 16,
    VT_TEXTDISPLAYTYPE = 18,
    VT_TEXTSPEED = 20,
    VT_DELAYTIME = 22
  };
  uint32_t uid() const {
    return GetField<uint32_t>(VT_UID, 0);
  }
  bool KeyCompareLessThan(const StoryRow * const o) const {
    return uid() < o->uid();
  }
  int KeyCompareWithValue(uint32_t _uid) const {
    return static_cast<int>(uid() > _uid) - static_cast<int>(uid() < _uid);
  }
  int32_t StoryId() const {
    return GetField<int32_t>(VT_STORYID, 0);
  }
  uint32_t GroupId() const {
    return GetField<uint32_t>(VT_GROUPID, 0);
  }
  uint32_t TalkerRoboId() const {
    return GetField<uint32_t>(VT_TALKERROBOID, 0);
  }
  int32_t TextUI() const {
    return GetField<int32_t>(VT_TEXTUI, 0);
  }
  bool CloseUIWhenFinish() const {
    return GetField<uint8_t>(VT_CLOSEUIWHENFINISH, 0) != 0;
  }
  const ::flatbuffers::String *TextContent() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTCONTENT);
  }
  fb::TextDisplayType TextDisplayType() const {
    return static_cast<fb::TextDisplayType>(GetField<int32_t>(VT_TEXTDISPLAYTYPE, 0));
  }
  int32_t TextSpeed() const {
    return GetField<int32_t>(VT_TEXTSPEED, 0);
  }
  int32_t DelayTime() const {
    return GetField<int32_t>(VT_DELAYTIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UID, 4) &&
           VerifyField<int32_t>(verifier, VT_STORYID, 4) &&
           VerifyField<uint32_t>(verifier, VT_GROUPID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TALKERROBOID, 4) &&
           VerifyField<int32_t>(verifier, VT_TEXTUI, 4) &&
           VerifyField<uint8_t>(verifier, VT_CLOSEUIWHENFINISH, 1) &&
           VerifyOffset(verifier, VT_TEXTCONTENT) &&
           verifier.VerifyString(TextContent()) &&
           VerifyField<int32_t>(verifier, VT_TEXTDISPLAYTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_TEXTSPEED, 4) &&
           VerifyField<int32_t>(verifier, VT_DELAYTIME, 4) &&
           verifier.EndTable();
  }
  StoryRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoryRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StoryRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoryRowBuilder {
  typedef StoryRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uid(uint32_t uid) {
    fbb_.AddElement<uint32_t>(StoryRow::VT_UID, uid, 0);
  }
  void add_StoryId(int32_t StoryId) {
    fbb_.AddElement<int32_t>(StoryRow::VT_STORYID, StoryId, 0);
  }
  void add_GroupId(uint32_t GroupId) {
    fbb_.AddElement<uint32_t>(StoryRow::VT_GROUPID, GroupId, 0);
  }
  void add_TalkerRoboId(uint32_t TalkerRoboId) {
    fbb_.AddElement<uint32_t>(StoryRow::VT_TALKERROBOID, TalkerRoboId, 0);
  }
  void add_TextUI(int32_t TextUI) {
    fbb_.AddElement<int32_t>(StoryRow::VT_TEXTUI, TextUI, 0);
  }
  void add_CloseUIWhenFinish(bool CloseUIWhenFinish) {
    fbb_.AddElement<uint8_t>(StoryRow::VT_CLOSEUIWHENFINISH, static_cast<uint8_t>(CloseUIWhenFinish), 0);
  }
  void add_TextContent(::flatbuffers::Offset<::flatbuffers::String> TextContent) {
    fbb_.AddOffset(StoryRow::VT_TEXTCONTENT, TextContent);
  }
  void add_TextDisplayType(fb::TextDisplayType TextDisplayType) {
    fbb_.AddElement<int32_t>(StoryRow::VT_TEXTDISPLAYTYPE, static_cast<int32_t>(TextDisplayType), 0);
  }
  void add_TextSpeed(int32_t TextSpeed) {
    fbb_.AddElement<int32_t>(StoryRow::VT_TEXTSPEED, TextSpeed, 0);
  }
  void add_DelayTime(int32_t DelayTime) {
    fbb_.AddElement<int32_t>(StoryRow::VT_DELAYTIME, DelayTime, 0);
  }
  explicit StoryRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StoryRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StoryRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StoryRow> CreateStoryRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uid = 0,
    int32_t StoryId = 0,
    uint32_t GroupId = 0,
    uint32_t TalkerRoboId = 0,
    int32_t TextUI = 0,
    bool CloseUIWhenFinish = false,
    ::flatbuffers::Offset<::flatbuffers::String> TextContent = 0,
    fb::TextDisplayType TextDisplayType = fb::TextDisplayType_NONE,
    int32_t TextSpeed = 0,
    int32_t DelayTime = 0) {
  StoryRowBuilder builder_(_fbb);
  builder_.add_DelayTime(DelayTime);
  builder_.add_TextSpeed(TextSpeed);
  builder_.add_TextDisplayType(TextDisplayType);
  builder_.add_TextContent(TextContent);
  builder_.add_TextUI(TextUI);
  builder_.add_TalkerRoboId(TalkerRoboId);
  builder_.add_GroupId(GroupId);
  builder_.add_StoryId(StoryId);
  builder_.add_uid(uid);
  builder_.add_CloseUIWhenFinish(CloseUIWhenFinish);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StoryRow> CreateStoryRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t uid = 0,
    int32_t StoryId = 0,
    uint32_t GroupId = 0,
    uint32_t TalkerRoboId = 0,
    int32_t TextUI = 0,
    bool CloseUIWhenFinish = false,
    const char *TextContent = nullptr,
    fb::TextDisplayType TextDisplayType = fb::TextDisplayType_NONE,
    int32_t TextSpeed = 0,
    int32_t DelayTime = 0) {
  auto TextContent__ = TextContent ? _fbb.CreateString(TextContent) : 0;
  return fb::CreateStoryRow(
      _fbb,
      uid,
      StoryId,
      GroupId,
      TalkerRoboId,
      TextUI,
      CloseUIWhenFinish,
      TextContent__,
      TextDisplayType,
      TextSpeed,
      DelayTime);
}

::flatbuffers::Offset<StoryRow> CreateStoryRow(::flatbuffers::FlatBufferBuilder &_fbb, const StoryRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StoryT::StoryT(const StoryT &o) {
  Storys.reserve(o.Storys.size());
  for (const auto &Storys_ : o.Storys) { Storys.emplace_back((Storys_) ? new fb::StoryRowT(*Storys_) : nullptr); }
}

inline StoryT &StoryT::operator=(StoryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Storys, o.Storys);
  return *this;
}

inline StoryT *Story::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StoryT>(new StoryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Story::UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Storys(); if (_e) { _o->Storys.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Storys[_i]) { _e->Get(_i)->UnPackTo(_o->Storys[_i].get(), _resolver); } else { _o->Storys[_i] = std::unique_ptr<fb::StoryRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Storys.resize(0); } }
}

inline ::flatbuffers::Offset<Story> Story::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStory(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StoryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Storys = _o->Storys.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::StoryRow>> (_o->Storys.size(), [](size_t i, _VectorArgs *__va) { return CreateStoryRow(*__va->__fbb, __va->__o->Storys[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateStory(
      _fbb,
      _Storys);
}

inline StoryRowT *StoryRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StoryRowT>(new StoryRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StoryRow::UnPackTo(StoryRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; }
  { auto _e = StoryId(); _o->StoryId = _e; }
  { auto _e = GroupId(); _o->GroupId = _e; }
  { auto _e = TalkerRoboId(); _o->TalkerRoboId = _e; }
  { auto _e = TextUI(); _o->TextUI = _e; }
  { auto _e = CloseUIWhenFinish(); _o->CloseUIWhenFinish = _e; }
  { auto _e = TextContent(); if (_e) _o->TextContent = _e->str(); }
  { auto _e = TextDisplayType(); _o->TextDisplayType = _e; }
  { auto _e = TextSpeed(); _o->TextSpeed = _e; }
  { auto _e = DelayTime(); _o->DelayTime = _e; }
}

inline ::flatbuffers::Offset<StoryRow> StoryRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStoryRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StoryRow> CreateStoryRow(::flatbuffers::FlatBufferBuilder &_fbb, const StoryRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StoryRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uid = _o->uid;
  auto _StoryId = _o->StoryId;
  auto _GroupId = _o->GroupId;
  auto _TalkerRoboId = _o->TalkerRoboId;
  auto _TextUI = _o->TextUI;
  auto _CloseUIWhenFinish = _o->CloseUIWhenFinish;
  auto _TextContent = _o->TextContent.empty() ? 0 : _fbb.CreateString(_o->TextContent);
  auto _TextDisplayType = _o->TextDisplayType;
  auto _TextSpeed = _o->TextSpeed;
  auto _DelayTime = _o->DelayTime;
  return fb::CreateStoryRow(
      _fbb,
      _uid,
      _StoryId,
      _GroupId,
      _TalkerRoboId,
      _TextUI,
      _CloseUIWhenFinish,
      _TextContent,
      _TextDisplayType,
      _TextSpeed,
      _DelayTime);
}

inline const fb::Story *GetStory(const void *buf) {
  return ::flatbuffers::GetRoot<fb::Story>(buf);
}

inline const fb::Story *GetSizePrefixedStory(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::Story>(buf);
}

inline bool VerifyStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::Story>(nullptr);
}

inline bool VerifySizePrefixedStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::Story>(nullptr);
}

inline void FinishStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Story> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Story> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::StoryT> UnPackStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::StoryT>(GetStory(buf)->UnPack(res));
}

inline std::unique_ptr<fb::StoryT> UnPackSizePrefixedStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::StoryT>(GetSizePrefixedStory(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_STORY_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ITEM_FB_H_
#define FLATBUFFERS_GENERATED_ITEM_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct Item;
struct ItemBuilder;
struct ItemT;

struct ItemRow;
struct ItemRowBuilder;
struct ItemRowT;

struct ItemT : public ::flatbuffers::NativeTable {
  typedef Item TableType;
  std::vector<std::unique_ptr<fb::ItemRowT>> Items{};
  ItemT() = default;
  ItemT(const ItemT &o);
  ItemT(ItemT&&) FLATBUFFERS_NOEXCEPT = default;
  ItemT &operator=(ItemT o) FLATBUFFERS_NOEXCEPT;
};

struct Item FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemT NativeTableType;
  typedef ItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::ItemRow>> *Items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::ItemRow>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(Items()) &&
           verifier.VerifyVectorOfTables(Items()) &&
           verifier.EndTable();
  }
  ItemT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Item> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemBuilder {
  typedef Item Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::ItemRow>>> Items) {
    fbb_.AddOffset(Item::VT_ITEMS, Items);
  }
  explicit ItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Item> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Item>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Item> CreateItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::ItemRow>>> Items = 0) {
  ItemBuilder builder_(_fbb);
  builder_.add_Items(Items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Item> CreateItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::ItemRow>> *Items = nullptr) {
  auto Items__ = Items ? _fbb.CreateVector<::flatbuffers::Offset<fb::ItemRow>>(*Items) : 0;
  return fb::CreateItem(
      _fbb,
      Items__);
}

::flatbuffers::Offset<Item> CreateItem(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemRowT : public ::flatbuffers::NativeTable {
  typedef ItemRow TableType;
  uint32_t Id = 0;
  int32_t Name = 0;
  fb::ItemType ItemType = fb::ItemType_NONE;
  std::string Desc{};
  std::string Icon{};
  int32_t MaxNum = 0;
  bool CanSell = false;
  uint32_t SellSC = 0;
  std::vector<std::unique_ptr<fb::tuple_uint32_uint32T>> SellItem{};
  std::vector<int32_t> UseParam{};
  uint32_t FoodSelectGroup = 0;
  ItemRowT() = default;
  ItemRowT(const ItemRowT &o);
  ItemRowT(ItemRowT&&) FLATBUFFERS_NOEXCEPT = default;
  ItemRowT &operator=(ItemRowT o) FLATBUFFERS_NOEXCEPT;
};

struct ItemRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemRowT NativeTableType;
  typedef ItemRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_ITEMTYPE = 8,
    VT_DESC = 10,
    VT_ICON = 12,
    VT_MAXNUM = 14,
    VT_CANSELL = 16,
    VT_SELLSC = 18,
    VT_SELLITEM = 20,
    VT_USEPARAM = 22,
    VT_FOODSELECTGROUP = 24
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t Name() const {
    return GetField<int32_t>(VT_NAME, 0);
  }
  fb::ItemType ItemType() const {
    return static_cast<fb::ItemType>(GetField<int32_t>(VT_ITEMTYPE, 0));
  }
  const ::flatbuffers::String *Desc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESC);
  }
  const ::flatbuffers::String *Icon() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICON);
  }
  int32_t MaxNum() const {
    return GetField<int32_t>(VT_MAXNUM, 0);
  }
  bool CanSell() const {
    return GetField<uint8_t>(VT_CANSELL, 0) != 0;
  }
  uint32_t SellSC() const {
    return GetField<uint32_t>(VT_SELLSC, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *SellItem() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *>(VT_SELLITEM);
  }
  const ::flatbuffers::Vector<int32_t> *UseParam() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_USEPARAM);
  }
  uint32_t FoodSelectGroup() const {
    return GetField<uint32_t>(VT_FOODSELECTGROUP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_NAME, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEMTYPE, 4) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyString(Desc()) &&
           VerifyOffset(verifier, VT_ICON) &&
           verifier.VerifyString(Icon()) &&
           VerifyField<int32_t>(verifier, VT_MAXNUM, 4) &&
           VerifyField<uint8_t>(verifier, VT_CANSELL, 1) &&
           VerifyField<uint32_t>(verifier, VT_SELLSC, 4) &&
           VerifyOffset(verifier, VT_SELLITEM) &&
           verifier.VerifyVector(SellItem()) &&
           verifier.VerifyVectorOfTables(SellItem()) &&
           VerifyOffset(verifier, VT_USEPARAM) &&
           verifier.VerifyVector(UseParam()) &&
           VerifyField<uint32_t>(verifier, VT_FOODSELECTGROUP, 4) &&
           verifier.EndTable();
  }
  ItemRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ItemRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ItemRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemRowBuilder {
  typedef ItemRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(ItemRow::VT_ID, Id, 0);
  }
  void add_Name(int32_t Name) {
    fbb_.AddElement<int32_t>(ItemRow::VT_NAME, Name, 0);
  }
  void add_ItemType(fb::ItemType ItemType) {
    fbb_.AddElement<int32_t>(ItemRow::VT_ITEMTYPE, static_cast<int32_t>(ItemType), 0);
  }
  void add_Desc(::flatbuffers::Offset<::flatbuffers::String> Desc) {
    fbb_.AddOffset(ItemRow::VT_DESC, Desc);
  }
  void add_Icon(::flatbuffers::Offset<::flatbuffers::String> Icon) {
    fbb_.AddOffset(ItemRow::VT_ICON, Icon);
  }
  void add_MaxNum(int32_t MaxNum) {
    fbb_.AddElement<int32_t>(ItemRow::VT_MAXNUM, MaxNum, 0);
  }
  void add_CanSell(bool CanSell) {
    fbb_.AddElement<uint8_t>(ItemRow::VT_CANSELL, static_cast<uint8_t>(CanSell), 0);
  }
  void add_SellSC(uint32_t SellSC) {
    fbb_.AddElement<uint32_t>(ItemRow::VT_SELLSC, SellSC, 0);
  }
  void add_SellItem(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>> SellItem) {
    fbb_.AddOffset(ItemRow::VT_SELLITEM, SellItem);
  }
  void add_UseParam(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> UseParam) {
    fbb_.AddOffset(ItemRow::VT_USEPARAM, UseParam);
  }
  void add_FoodSelectGroup(uint32_t FoodSelectGroup) {
    fbb_.AddElement<uint32_t>(ItemRow::VT_FOODSELECTGROUP, FoodSelectGroup, 0);
  }
  explicit ItemRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItemRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItemRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ItemRow> CreateItemRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    int32_t Name = 0,
    fb::ItemType ItemType = fb::ItemType_NONE,
    ::flatbuffers::Offset<::flatbuffers::String> Desc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Icon = 0,
    int32_t MaxNum = 0,
    bool CanSell = false,
    uint32_t SellSC = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>> SellItem = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> UseParam = 0,
    uint32_t FoodSelectGroup = 0) {
  ItemRowBuilder builder_(_fbb);
  builder_.add_FoodSelectGroup(FoodSelectGroup);
  builder_.add_UseParam(UseParam);
  builder_.add_SellItem(SellItem);
  builder_.add_SellSC(SellSC);
  builder_.add_MaxNum(MaxNum);
  builder_.add_Icon(Icon);
  builder_.add_Desc(Desc);
  builder_.add_ItemType(ItemType);
  builder_.add_Name(Name);
  builder_.add_Id(Id);
  builder_.add_CanSell(CanSell);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ItemRow> CreateItemRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    int32_t Name = 0,
    fb::ItemType ItemType = fb::ItemType_NONE,
    const char *Desc = nullptr,
    const char *Icon = nullptr,
    int32_t MaxNum = 0,
    bool CanSell = false,
    uint32_t SellSC = 0,
    const std::vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *SellItem = nullptr,
    const std::vector<int32_t> *UseParam = nullptr,
    uint32_t FoodSelectGroup = 0) {
  auto Desc__ = Desc ? _fbb.CreateString(Desc) : 0;
  auto Icon__ = Icon ? _fbb.CreateString(Icon) : 0;
  auto SellItem__ = SellItem ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>(*SellItem) : 0;
  auto UseParam__ = UseParam ? _fbb.CreateVector<int32_t>(*UseParam) : 0;
  return fb::CreateItemRow(
      _fbb,
      Id,
      Name,
      ItemType,
      Desc__,
      Icon__,
      MaxNum,
      CanSell,
      SellSC,
      SellItem__,
      UseParam__,
      FoodSelectGroup);
}

::flatbuffers::Offset<ItemRow> CreateItemRow(::flatbuffers::FlatBufferBuilder &_fbb, const ItemRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ItemT::ItemT(const ItemT &o) {
  Items.reserve(o.Items.size());
  for (const auto &Items_ : o.Items) { Items.emplace_back((Items_) ? new fb::ItemRowT(*Items_) : nullptr); }
}

inline ItemT &ItemT::operator=(ItemT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Items, o.Items);
  return *this;
}

inline ItemT *Item::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemT>(new ItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Item::UnPackTo(ItemT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Items(); if (_e) { _o->Items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Items[_i]) { _e->Get(_i)->UnPackTo(_o->Items[_i].get(), _resolver); } else { _o->Items[_i] = std::unique_ptr<fb::ItemRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Items.resize(0); } }
}

inline ::flatbuffers::Offset<Item> Item::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItem(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Item> CreateItem(::flatbuffers::FlatBufferBuilder &_fbb, const ItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ItemT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Items = _o->Items.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::ItemRow>> (_o->Items.size(), [](size_t i, _VectorArgs *__va) { return CreateItemRow(*__va->__fbb, __va->__o->Items[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateItem(
      _fbb,
      _Items);
}

inline ItemRowT::ItemRowT(const ItemRowT &o)
      : Id(o.Id),
        Name(o.Name),
        ItemType(o.ItemType),
        Desc(o.Desc),
        Icon(o.Icon),
        MaxNum(o.MaxNum),
        CanSell(o.CanSell),
        SellSC(o.SellSC),
        UseParam(o.UseParam),
        FoodSelectGroup(o.FoodSelectGroup) {
  SellItem.reserve(o.SellItem.size());
  for (const auto &SellItem_ : o.SellItem) { SellItem.emplace_back((SellItem_) ? new fb::tuple_uint32_uint32T(*SellItem_) : nullptr); }
}

inline ItemRowT &ItemRowT::operator=(ItemRowT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(Name, o.Name);
  std::swap(ItemType, o.ItemType);
  std::swap(Desc, o.Desc);
  std::swap(Icon, o.Icon);
  std::swap(MaxNum, o.MaxNum);
  std::swap(CanSell, o.CanSell);
  std::swap(SellSC, o.SellSC);
  std::swap(SellItem, o.SellItem);
  std::swap(UseParam, o.UseParam);
  std::swap(FoodSelectGroup, o.FoodSelectGroup);
  return *this;
}

inline ItemRowT *ItemRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemRowT>(new ItemRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemRow::UnPackTo(ItemRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = Name(); _o->Name = _e; }
  { auto _e = ItemType(); _o->ItemType = _e; }
  { auto _e = Desc(); if (_e) _o->Desc = _e->str(); }
  { auto _e = Icon(); if (_e) _o->Icon = _e->str(); }
  { auto _e = MaxNum(); _o->MaxNum = _e; }
  { auto _e = CanSell(); _o->CanSell = _e; }
  { auto _e = SellSC(); _o->SellSC = _e; }
  { auto _e = SellItem(); if (_e) { _o->SellItem.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->SellItem[_i]) { _e->Get(_i)->UnPackTo(_o->SellItem[_i].get(), _resolver); } else { _o->SellItem[_i] = std::unique_ptr<fb::tuple_uint32_uint32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->SellItem.resize(0); } }
  { auto _e = UseParam(); if (_e) { _o->UseParam.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->UseParam[_i] = _e->Get(_i); } } else { _o->UseParam.resize(0); } }
  { auto _e = FoodSelectGroup(); _o->FoodSelectGroup = _e; }
}

inline ::flatbuffers::Offset<ItemRow> ItemRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ItemRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ItemRow> CreateItemRow(::flatbuffers::FlatBufferBuilder &_fbb, const ItemRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ItemRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _Name = _o->Name;
  auto _ItemType = _o->ItemType;
  auto _Desc = _o->Desc.empty() ? 0 : _fbb.CreateString(_o->Desc);
  auto _Icon = _o->Icon.empty() ? 0 : _fbb.CreateString(_o->Icon);
  auto _MaxNum = _o->MaxNum;
  auto _CanSell = _o->CanSell;
  auto _SellSC = _o->SellSC;
  auto _SellItem = _o->SellItem.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> (_o->SellItem.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_uint32_uint32(*__va->__fbb, __va->__o->SellItem[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _UseParam = _o->UseParam.size() ? _fbb.CreateVector(_o->UseParam) : 0;
  auto _FoodSelectGroup = _o->FoodSelectGroup;
  return fb::CreateItemRow(
      _fbb,
      _Id,
      _Name,
      _ItemType,
      _Desc,
      _Icon,
      _MaxNum,
      _CanSell,
      _SellSC,
      _SellItem,
      _UseParam,
      _FoodSelectGroup);
}

inline const fb::Item *GetItem(const void *buf) {
  return ::flatbuffers::GetRoot<fb::Item>(buf);
}

inline const fb::Item *GetSizePrefixedItem(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::Item>(buf);
}

inline bool VerifyItemBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::Item>(nullptr);
}

inline bool VerifySizePrefixedItemBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::Item>(nullptr);
}

inline void FinishItemBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Item> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedItemBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Item> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::ItemT> UnPackItem(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::ItemT>(GetItem(buf)->UnPack(res));
}

inline std::unique_ptr<fb::ItemT> UnPackSizePrefixedItem(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::ItemT>(GetSizePrefixedItem(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ITEM_FB_H_

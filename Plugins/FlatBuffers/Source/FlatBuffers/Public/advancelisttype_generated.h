// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ADVANCELISTTYPE_FB_H_
#define FLATBUFFERS_GENERATED_ADVANCELISTTYPE_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct AdvanceListType;
struct AdvanceListTypeBuilder;
struct AdvanceListTypeT;

struct AdvanceListTypeRow;
struct AdvanceListTypeRowBuilder;
struct AdvanceListTypeRowT;

struct AdvanceListTypeT : public ::flatbuffers::NativeTable {
  typedef AdvanceListType TableType;
  std::vector<std::unique_ptr<fb::AdvanceListTypeRowT>> AdvanceListTypes{};
  AdvanceListTypeT() = default;
  AdvanceListTypeT(const AdvanceListTypeT &o);
  AdvanceListTypeT(AdvanceListTypeT&&) FLATBUFFERS_NOEXCEPT = default;
  AdvanceListTypeT &operator=(AdvanceListTypeT o) FLATBUFFERS_NOEXCEPT;
};

struct AdvanceListType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AdvanceListTypeT NativeTableType;
  typedef AdvanceListTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADVANCELISTTYPES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::AdvanceListTypeRow>> *AdvanceListTypes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::AdvanceListTypeRow>> *>(VT_ADVANCELISTTYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADVANCELISTTYPES) &&
           verifier.VerifyVector(AdvanceListTypes()) &&
           verifier.VerifyVectorOfTables(AdvanceListTypes()) &&
           verifier.EndTable();
  }
  AdvanceListTypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdvanceListTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AdvanceListType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdvanceListTypeBuilder {
  typedef AdvanceListType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_AdvanceListTypes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::AdvanceListTypeRow>>> AdvanceListTypes) {
    fbb_.AddOffset(AdvanceListType::VT_ADVANCELISTTYPES, AdvanceListTypes);
  }
  explicit AdvanceListTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AdvanceListType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AdvanceListType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AdvanceListType> CreateAdvanceListType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::AdvanceListTypeRow>>> AdvanceListTypes = 0) {
  AdvanceListTypeBuilder builder_(_fbb);
  builder_.add_AdvanceListTypes(AdvanceListTypes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AdvanceListType> CreateAdvanceListTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::AdvanceListTypeRow>> *AdvanceListTypes = nullptr) {
  auto AdvanceListTypes__ = AdvanceListTypes ? _fbb.CreateVector<::flatbuffers::Offset<fb::AdvanceListTypeRow>>(*AdvanceListTypes) : 0;
  return fb::CreateAdvanceListType(
      _fbb,
      AdvanceListTypes__);
}

::flatbuffers::Offset<AdvanceListType> CreateAdvanceListType(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AdvanceListTypeRowT : public ::flatbuffers::NativeTable {
  typedef AdvanceListTypeRow TableType;
  int32_t Id = 0;
  std::vector<std::unique_ptr<fb::list_int32T>> VList2{};
  std::vector<std::unique_ptr<fb::tuple_int32_stringT>> VList3{};
  std::vector<std::unique_ptr<fb::tuple_int32_list_stringT>> VList4{};
  AdvanceListTypeRowT() = default;
  AdvanceListTypeRowT(const AdvanceListTypeRowT &o);
  AdvanceListTypeRowT(AdvanceListTypeRowT&&) FLATBUFFERS_NOEXCEPT = default;
  AdvanceListTypeRowT &operator=(AdvanceListTypeRowT o) FLATBUFFERS_NOEXCEPT;
};

struct AdvanceListTypeRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AdvanceListTypeRowT NativeTableType;
  typedef AdvanceListTypeRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VLIST2 = 6,
    VT_VLIST3 = 8,
    VT_VLIST4 = 10
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::list_int32>> *VList2() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::list_int32>> *>(VT_VLIST2);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_string>> *VList3() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_string>> *>(VT_VLIST3);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_list_string>> *VList4() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_list_string>> *>(VT_VLIST4);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_VLIST2) &&
           verifier.VerifyVector(VList2()) &&
           verifier.VerifyVectorOfTables(VList2()) &&
           VerifyOffset(verifier, VT_VLIST3) &&
           verifier.VerifyVector(VList3()) &&
           verifier.VerifyVectorOfTables(VList3()) &&
           VerifyOffset(verifier, VT_VLIST4) &&
           verifier.VerifyVector(VList4()) &&
           verifier.VerifyVectorOfTables(VList4()) &&
           verifier.EndTable();
  }
  AdvanceListTypeRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdvanceListTypeRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AdvanceListTypeRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdvanceListTypeRowBuilder {
  typedef AdvanceListTypeRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(AdvanceListTypeRow::VT_ID, Id, 0);
  }
  void add_VList2(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::list_int32>>> VList2) {
    fbb_.AddOffset(AdvanceListTypeRow::VT_VLIST2, VList2);
  }
  void add_VList3(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_string>>> VList3) {
    fbb_.AddOffset(AdvanceListTypeRow::VT_VLIST3, VList3);
  }
  void add_VList4(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_list_string>>> VList4) {
    fbb_.AddOffset(AdvanceListTypeRow::VT_VLIST4, VList4);
  }
  explicit AdvanceListTypeRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AdvanceListTypeRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AdvanceListTypeRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AdvanceListTypeRow> CreateAdvanceListTypeRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::list_int32>>> VList2 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_string>>> VList3 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_int32_list_string>>> VList4 = 0) {
  AdvanceListTypeRowBuilder builder_(_fbb);
  builder_.add_VList4(VList4);
  builder_.add_VList3(VList3);
  builder_.add_VList2(VList2);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AdvanceListTypeRow> CreateAdvanceListTypeRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    const std::vector<::flatbuffers::Offset<fb::list_int32>> *VList2 = nullptr,
    const std::vector<::flatbuffers::Offset<fb::tuple_int32_string>> *VList3 = nullptr,
    const std::vector<::flatbuffers::Offset<fb::tuple_int32_list_string>> *VList4 = nullptr) {
  auto VList2__ = VList2 ? _fbb.CreateVector<::flatbuffers::Offset<fb::list_int32>>(*VList2) : 0;
  auto VList3__ = VList3 ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_int32_string>>(*VList3) : 0;
  auto VList4__ = VList4 ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_int32_list_string>>(*VList4) : 0;
  return fb::CreateAdvanceListTypeRow(
      _fbb,
      Id,
      VList2__,
      VList3__,
      VList4__);
}

::flatbuffers::Offset<AdvanceListTypeRow> CreateAdvanceListTypeRow(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AdvanceListTypeT::AdvanceListTypeT(const AdvanceListTypeT &o) {
  AdvanceListTypes.reserve(o.AdvanceListTypes.size());
  for (const auto &AdvanceListTypes_ : o.AdvanceListTypes) { AdvanceListTypes.emplace_back((AdvanceListTypes_) ? new fb::AdvanceListTypeRowT(*AdvanceListTypes_) : nullptr); }
}

inline AdvanceListTypeT &AdvanceListTypeT::operator=(AdvanceListTypeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(AdvanceListTypes, o.AdvanceListTypes);
  return *this;
}

inline AdvanceListTypeT *AdvanceListType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdvanceListTypeT>(new AdvanceListTypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AdvanceListType::UnPackTo(AdvanceListTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AdvanceListTypes(); if (_e) { _o->AdvanceListTypes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->AdvanceListTypes[_i]) { _e->Get(_i)->UnPackTo(_o->AdvanceListTypes[_i].get(), _resolver); } else { _o->AdvanceListTypes[_i] = std::unique_ptr<fb::AdvanceListTypeRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->AdvanceListTypes.resize(0); } }
}

inline ::flatbuffers::Offset<AdvanceListType> AdvanceListType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdvanceListType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AdvanceListType> CreateAdvanceListType(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AdvanceListTypeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AdvanceListTypes = _o->AdvanceListTypes.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::AdvanceListTypeRow>> (_o->AdvanceListTypes.size(), [](size_t i, _VectorArgs *__va) { return CreateAdvanceListTypeRow(*__va->__fbb, __va->__o->AdvanceListTypes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateAdvanceListType(
      _fbb,
      _AdvanceListTypes);
}

inline AdvanceListTypeRowT::AdvanceListTypeRowT(const AdvanceListTypeRowT &o)
      : Id(o.Id) {
  VList2.reserve(o.VList2.size());
  for (const auto &VList2_ : o.VList2) { VList2.emplace_back((VList2_) ? new fb::list_int32T(*VList2_) : nullptr); }
  VList3.reserve(o.VList3.size());
  for (const auto &VList3_ : o.VList3) { VList3.emplace_back((VList3_) ? new fb::tuple_int32_stringT(*VList3_) : nullptr); }
  VList4.reserve(o.VList4.size());
  for (const auto &VList4_ : o.VList4) { VList4.emplace_back((VList4_) ? new fb::tuple_int32_list_stringT(*VList4_) : nullptr); }
}

inline AdvanceListTypeRowT &AdvanceListTypeRowT::operator=(AdvanceListTypeRowT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(VList2, o.VList2);
  std::swap(VList3, o.VList3);
  std::swap(VList4, o.VList4);
  return *this;
}

inline AdvanceListTypeRowT *AdvanceListTypeRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdvanceListTypeRowT>(new AdvanceListTypeRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AdvanceListTypeRow::UnPackTo(AdvanceListTypeRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = VList2(); if (_e) { _o->VList2.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->VList2[_i]) { _e->Get(_i)->UnPackTo(_o->VList2[_i].get(), _resolver); } else { _o->VList2[_i] = std::unique_ptr<fb::list_int32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->VList2.resize(0); } }
  { auto _e = VList3(); if (_e) { _o->VList3.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->VList3[_i]) { _e->Get(_i)->UnPackTo(_o->VList3[_i].get(), _resolver); } else { _o->VList3[_i] = std::unique_ptr<fb::tuple_int32_stringT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->VList3.resize(0); } }
  { auto _e = VList4(); if (_e) { _o->VList4.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->VList4[_i]) { _e->Get(_i)->UnPackTo(_o->VList4[_i].get(), _resolver); } else { _o->VList4[_i] = std::unique_ptr<fb::tuple_int32_list_stringT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->VList4.resize(0); } }
}

inline ::flatbuffers::Offset<AdvanceListTypeRow> AdvanceListTypeRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdvanceListTypeRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AdvanceListTypeRow> CreateAdvanceListTypeRow(::flatbuffers::FlatBufferBuilder &_fbb, const AdvanceListTypeRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AdvanceListTypeRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _VList2 = _o->VList2.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::list_int32>> (_o->VList2.size(), [](size_t i, _VectorArgs *__va) { return Createlist_int32(*__va->__fbb, __va->__o->VList2[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _VList3 = _o->VList3.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_int32_string>> (_o->VList3.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_int32_string(*__va->__fbb, __va->__o->VList3[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _VList4 = _o->VList4.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_int32_list_string>> (_o->VList4.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_int32_list_string(*__va->__fbb, __va->__o->VList4[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateAdvanceListTypeRow(
      _fbb,
      _Id,
      _VList2,
      _VList3,
      _VList4);
}

inline const fb::AdvanceListType *GetAdvanceListType(const void *buf) {
  return ::flatbuffers::GetRoot<fb::AdvanceListType>(buf);
}

inline const fb::AdvanceListType *GetSizePrefixedAdvanceListType(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::AdvanceListType>(buf);
}

inline bool VerifyAdvanceListTypeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::AdvanceListType>(nullptr);
}

inline bool VerifySizePrefixedAdvanceListTypeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::AdvanceListType>(nullptr);
}

inline void FinishAdvanceListTypeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::AdvanceListType> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAdvanceListTypeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::AdvanceListType> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::AdvanceListTypeT> UnPackAdvanceListType(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::AdvanceListTypeT>(GetAdvanceListType(buf)->UnPack(res));
}

inline std::unique_ptr<fb::AdvanceListTypeT> UnPackSizePrefixedAdvanceListType(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::AdvanceListTypeT>(GetSizePrefixedAdvanceListType(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ADVANCELISTTYPE_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_FB_H_
#define FLATBUFFERS_GENERATED_COMMON_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct list_int32;
struct list_int32Builder;
struct list_int32T;

struct tuple_int32_string;
struct tuple_int32_stringBuilder;
struct tuple_int32_stringT;

struct list_string;
struct list_stringBuilder;
struct list_stringT;

struct tuple_int32_list_string;
struct tuple_int32_list_stringBuilder;
struct tuple_int32_list_stringT;

struct tuple_uint32_uint32;
struct tuple_uint32_uint32Builder;
struct tuple_uint32_uint32T;

struct tuple_float32_float32_float32;
struct tuple_float32_float32_float32Builder;
struct tuple_float32_float32_float32T;

struct tuple_float32_float32_float32_float32;
struct tuple_float32_float32_float32_float32Builder;
struct tuple_float32_float32_float32_float32T;

struct tuple_int32_int32;
struct tuple_int32_int32Builder;
struct tuple_int32_int32T;

struct tuple_uint32_uint32_uint32;
struct tuple_uint32_uint32_uint32Builder;
struct tuple_uint32_uint32_uint32T;

struct map_int32_int32;
struct map_int32_int32Builder;
struct map_int32_int32T;

struct tuple_int32_int32_int32;
struct tuple_int32_int32_int32Builder;
struct tuple_int32_int32_int32T;

struct tuple_int32_string_list_uint32;
struct tuple_int32_string_list_uint32Builder;
struct tuple_int32_string_list_uint32T;

struct map_int32_int64;
struct map_int32_int64Builder;
struct map_int32_int64T;

struct tuple_int32_tuple_uint32_string;
struct tuple_int32_tuple_uint32_stringBuilder;
struct tuple_int32_tuple_uint32_stringT;

struct list_uint32;
struct list_uint32Builder;
struct list_uint32T;

struct tuple_uint32_string;
struct tuple_uint32_stringBuilder;
struct tuple_uint32_stringT;

struct list_int32T : public ::flatbuffers::NativeTable {
  typedef list_int32 TableType;
  std::vector<int32_t> items{};
};

struct list_int32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef list_int32T NativeTableType;
  typedef list_int32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
  list_int32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(list_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<list_int32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const list_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct list_int32Builder {
  typedef list_int32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items) {
    fbb_.AddOffset(list_int32::VT_ITEMS, items);
  }
  explicit list_int32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<list_int32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<list_int32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<list_int32> Createlist_int32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items = 0) {
  list_int32Builder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<list_int32> Createlist_int32Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int32_t>(*items) : 0;
  return fb::Createlist_int32(
      _fbb,
      items__);
}

::flatbuffers::Offset<list_int32> Createlist_int32(::flatbuffers::FlatBufferBuilder &_fbb, const list_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_int32_stringT : public ::flatbuffers::NativeTable {
  typedef tuple_int32_string TableType;
  int32_t item1 = 0;
  std::string item2{};
};

struct tuple_int32_string FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_int32_stringT NativeTableType;
  typedef tuple_int32_stringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6
  };
  int32_t item1() const {
    return GetField<int32_t>(VT_ITEM1, 0);
  }
  const ::flatbuffers::String *item2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ITEM2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM1, 4) &&
           VerifyOffset(verifier, VT_ITEM2) &&
           verifier.VerifyString(item2()) &&
           verifier.EndTable();
  }
  tuple_int32_stringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_int32_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_int32_string> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_int32_stringBuilder {
  typedef tuple_int32_string Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(int32_t item1) {
    fbb_.AddElement<int32_t>(tuple_int32_string::VT_ITEM1, item1, 0);
  }
  void add_item2(::flatbuffers::Offset<::flatbuffers::String> item2) {
    fbb_.AddOffset(tuple_int32_string::VT_ITEM2, item2);
  }
  explicit tuple_int32_stringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_int32_string> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_int32_string>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_int32_string> Createtuple_int32_string(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> item2 = 0) {
  tuple_int32_stringBuilder builder_(_fbb);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<tuple_int32_string> Createtuple_int32_stringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    const char *item2 = nullptr) {
  auto item2__ = item2 ? _fbb.CreateString(item2) : 0;
  return fb::Createtuple_int32_string(
      _fbb,
      item1,
      item2__);
}

::flatbuffers::Offset<tuple_int32_string> Createtuple_int32_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct list_stringT : public ::flatbuffers::NativeTable {
  typedef list_string TableType;
  std::vector<std::string> items{};
};

struct list_string FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef list_stringT NativeTableType;
  typedef list_stringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.VerifyVectorOfStrings(items()) &&
           verifier.EndTable();
  }
  list_stringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(list_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<list_string> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const list_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct list_stringBuilder {
  typedef list_string Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> items) {
    fbb_.AddOffset(list_string::VT_ITEMS, items);
  }
  explicit list_stringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<list_string> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<list_string>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<list_string> Createlist_string(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> items = 0) {
  list_stringBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<list_string> Createlist_stringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*items) : 0;
  return fb::Createlist_string(
      _fbb,
      items__);
}

::flatbuffers::Offset<list_string> Createlist_string(::flatbuffers::FlatBufferBuilder &_fbb, const list_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_int32_list_stringT : public ::flatbuffers::NativeTable {
  typedef tuple_int32_list_string TableType;
  int32_t item1 = 0;
  std::vector<std::string> item2{};
};

struct tuple_int32_list_string FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_int32_list_stringT NativeTableType;
  typedef tuple_int32_list_stringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6
  };
  int32_t item1() const {
    return GetField<int32_t>(VT_ITEM1, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *item2() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ITEM2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM1, 4) &&
           VerifyOffset(verifier, VT_ITEM2) &&
           verifier.VerifyVector(item2()) &&
           verifier.VerifyVectorOfStrings(item2()) &&
           verifier.EndTable();
  }
  tuple_int32_list_stringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_int32_list_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_int32_list_string> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_list_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_int32_list_stringBuilder {
  typedef tuple_int32_list_string Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(int32_t item1) {
    fbb_.AddElement<int32_t>(tuple_int32_list_string::VT_ITEM1, item1, 0);
  }
  void add_item2(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> item2) {
    fbb_.AddOffset(tuple_int32_list_string::VT_ITEM2, item2);
  }
  explicit tuple_int32_list_stringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_int32_list_string> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_int32_list_string>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_int32_list_string> Createtuple_int32_list_string(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> item2 = 0) {
  tuple_int32_list_stringBuilder builder_(_fbb);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<tuple_int32_list_string> Createtuple_int32_list_stringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *item2 = nullptr) {
  auto item2__ = item2 ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*item2) : 0;
  return fb::Createtuple_int32_list_string(
      _fbb,
      item1,
      item2__);
}

::flatbuffers::Offset<tuple_int32_list_string> Createtuple_int32_list_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_list_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_uint32_uint32T : public ::flatbuffers::NativeTable {
  typedef tuple_uint32_uint32 TableType;
  uint32_t item1 = 0;
  uint32_t item2 = 0;
};

struct tuple_uint32_uint32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_uint32_uint32T NativeTableType;
  typedef tuple_uint32_uint32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6
  };
  uint32_t item1() const {
    return GetField<uint32_t>(VT_ITEM1, 0);
  }
  uint32_t item2() const {
    return GetField<uint32_t>(VT_ITEM2, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ITEM1, 4) &&
           VerifyField<uint32_t>(verifier, VT_ITEM2, 4) &&
           verifier.EndTable();
  }
  tuple_uint32_uint32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_uint32_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_uint32_uint32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_uint32_uint32Builder {
  typedef tuple_uint32_uint32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(uint32_t item1) {
    fbb_.AddElement<uint32_t>(tuple_uint32_uint32::VT_ITEM1, item1, 0);
  }
  void add_item2(uint32_t item2) {
    fbb_.AddElement<uint32_t>(tuple_uint32_uint32::VT_ITEM2, item2, 0);
  }
  explicit tuple_uint32_uint32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_uint32_uint32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_uint32_uint32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_uint32_uint32> Createtuple_uint32_uint32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t item1 = 0,
    uint32_t item2 = 0) {
  tuple_uint32_uint32Builder builder_(_fbb);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_uint32_uint32> Createtuple_uint32_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_float32_float32_float32T : public ::flatbuffers::NativeTable {
  typedef tuple_float32_float32_float32 TableType;
  float item1 = 0.0f;
  float item2 = 0.0f;
  float item3 = 0.0f;
};

struct tuple_float32_float32_float32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_float32_float32_float32T NativeTableType;
  typedef tuple_float32_float32_float32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6,
    VT_ITEM3 = 8
  };
  float item1() const {
    return GetField<float>(VT_ITEM1, 0.0f);
  }
  float item2() const {
    return GetField<float>(VT_ITEM2, 0.0f);
  }
  float item3() const {
    return GetField<float>(VT_ITEM3, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ITEM1, 4) &&
           VerifyField<float>(verifier, VT_ITEM2, 4) &&
           VerifyField<float>(verifier, VT_ITEM3, 4) &&
           verifier.EndTable();
  }
  tuple_float32_float32_float32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_float32_float32_float32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_float32_float32_float32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_float32_float32_float32Builder {
  typedef tuple_float32_float32_float32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(float item1) {
    fbb_.AddElement<float>(tuple_float32_float32_float32::VT_ITEM1, item1, 0.0f);
  }
  void add_item2(float item2) {
    fbb_.AddElement<float>(tuple_float32_float32_float32::VT_ITEM2, item2, 0.0f);
  }
  void add_item3(float item3) {
    fbb_.AddElement<float>(tuple_float32_float32_float32::VT_ITEM3, item3, 0.0f);
  }
  explicit tuple_float32_float32_float32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_float32_float32_float32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_float32_float32_float32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_float32_float32_float32> Createtuple_float32_float32_float32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float item1 = 0.0f,
    float item2 = 0.0f,
    float item3 = 0.0f) {
  tuple_float32_float32_float32Builder builder_(_fbb);
  builder_.add_item3(item3);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_float32_float32_float32> Createtuple_float32_float32_float32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_float32_float32_float32_float32T : public ::flatbuffers::NativeTable {
  typedef tuple_float32_float32_float32_float32 TableType;
  float item1 = 0.0f;
  float item2 = 0.0f;
  float item3 = 0.0f;
  float item4 = 0.0f;
};

struct tuple_float32_float32_float32_float32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_float32_float32_float32_float32T NativeTableType;
  typedef tuple_float32_float32_float32_float32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6,
    VT_ITEM3 = 8,
    VT_ITEM4 = 10
  };
  float item1() const {
    return GetField<float>(VT_ITEM1, 0.0f);
  }
  float item2() const {
    return GetField<float>(VT_ITEM2, 0.0f);
  }
  float item3() const {
    return GetField<float>(VT_ITEM3, 0.0f);
  }
  float item4() const {
    return GetField<float>(VT_ITEM4, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ITEM1, 4) &&
           VerifyField<float>(verifier, VT_ITEM2, 4) &&
           VerifyField<float>(verifier, VT_ITEM3, 4) &&
           VerifyField<float>(verifier, VT_ITEM4, 4) &&
           verifier.EndTable();
  }
  tuple_float32_float32_float32_float32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_float32_float32_float32_float32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_float32_float32_float32_float32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32_float32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_float32_float32_float32_float32Builder {
  typedef tuple_float32_float32_float32_float32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(float item1) {
    fbb_.AddElement<float>(tuple_float32_float32_float32_float32::VT_ITEM1, item1, 0.0f);
  }
  void add_item2(float item2) {
    fbb_.AddElement<float>(tuple_float32_float32_float32_float32::VT_ITEM2, item2, 0.0f);
  }
  void add_item3(float item3) {
    fbb_.AddElement<float>(tuple_float32_float32_float32_float32::VT_ITEM3, item3, 0.0f);
  }
  void add_item4(float item4) {
    fbb_.AddElement<float>(tuple_float32_float32_float32_float32::VT_ITEM4, item4, 0.0f);
  }
  explicit tuple_float32_float32_float32_float32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_float32_float32_float32_float32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_float32_float32_float32_float32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_float32_float32_float32_float32> Createtuple_float32_float32_float32_float32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float item1 = 0.0f,
    float item2 = 0.0f,
    float item3 = 0.0f,
    float item4 = 0.0f) {
  tuple_float32_float32_float32_float32Builder builder_(_fbb);
  builder_.add_item4(item4);
  builder_.add_item3(item3);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_float32_float32_float32_float32> Createtuple_float32_float32_float32_float32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32_float32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_int32_int32T : public ::flatbuffers::NativeTable {
  typedef tuple_int32_int32 TableType;
  int32_t item1 = 0;
  int32_t item2 = 0;
};

struct tuple_int32_int32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_int32_int32T NativeTableType;
  typedef tuple_int32_int32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6
  };
  int32_t item1() const {
    return GetField<int32_t>(VT_ITEM1, 0);
  }
  int32_t item2() const {
    return GetField<int32_t>(VT_ITEM2, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM1, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEM2, 4) &&
           verifier.EndTable();
  }
  tuple_int32_int32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_int32_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_int32_int32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_int32_int32Builder {
  typedef tuple_int32_int32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(int32_t item1) {
    fbb_.AddElement<int32_t>(tuple_int32_int32::VT_ITEM1, item1, 0);
  }
  void add_item2(int32_t item2) {
    fbb_.AddElement<int32_t>(tuple_int32_int32::VT_ITEM2, item2, 0);
  }
  explicit tuple_int32_int32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_int32_int32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_int32_int32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_int32_int32> Createtuple_int32_int32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    int32_t item2 = 0) {
  tuple_int32_int32Builder builder_(_fbb);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_int32_int32> Createtuple_int32_int32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_uint32_uint32_uint32T : public ::flatbuffers::NativeTable {
  typedef tuple_uint32_uint32_uint32 TableType;
  uint32_t item1 = 0;
  uint32_t item2 = 0;
  uint32_t item3 = 0;
};

struct tuple_uint32_uint32_uint32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_uint32_uint32_uint32T NativeTableType;
  typedef tuple_uint32_uint32_uint32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6,
    VT_ITEM3 = 8
  };
  uint32_t item1() const {
    return GetField<uint32_t>(VT_ITEM1, 0);
  }
  uint32_t item2() const {
    return GetField<uint32_t>(VT_ITEM2, 0);
  }
  uint32_t item3() const {
    return GetField<uint32_t>(VT_ITEM3, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ITEM1, 4) &&
           VerifyField<uint32_t>(verifier, VT_ITEM2, 4) &&
           VerifyField<uint32_t>(verifier, VT_ITEM3, 4) &&
           verifier.EndTable();
  }
  tuple_uint32_uint32_uint32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_uint32_uint32_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_uint32_uint32_uint32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_uint32_uint32_uint32Builder {
  typedef tuple_uint32_uint32_uint32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(uint32_t item1) {
    fbb_.AddElement<uint32_t>(tuple_uint32_uint32_uint32::VT_ITEM1, item1, 0);
  }
  void add_item2(uint32_t item2) {
    fbb_.AddElement<uint32_t>(tuple_uint32_uint32_uint32::VT_ITEM2, item2, 0);
  }
  void add_item3(uint32_t item3) {
    fbb_.AddElement<uint32_t>(tuple_uint32_uint32_uint32::VT_ITEM3, item3, 0);
  }
  explicit tuple_uint32_uint32_uint32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_uint32_uint32_uint32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_uint32_uint32_uint32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_uint32_uint32_uint32> Createtuple_uint32_uint32_uint32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t item1 = 0,
    uint32_t item2 = 0,
    uint32_t item3 = 0) {
  tuple_uint32_uint32_uint32Builder builder_(_fbb);
  builder_.add_item3(item3);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_uint32_uint32_uint32> Createtuple_uint32_uint32_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct map_int32_int32T : public ::flatbuffers::NativeTable {
  typedef map_int32_int32 TableType;
  std::vector<int32_t> keys{};
  std::vector<int32_t> values{};
};

struct map_int32_int32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef map_int32_int32T NativeTableType;
  typedef map_int32_int32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::Vector<int32_t> *keys() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KEYS);
  }
  const ::flatbuffers::Vector<int32_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  map_int32_int32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(map_int32_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<map_int32_int32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct map_int32_int32Builder {
  typedef map_int32_int32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keys(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> keys) {
    fbb_.AddOffset(map_int32_int32::VT_KEYS, keys);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(map_int32_int32::VT_VALUES, values);
  }
  explicit map_int32_int32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<map_int32_int32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<map_int32_int32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<map_int32_int32> Createmap_int32_int32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> keys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> values = 0) {
  map_int32_int32Builder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<map_int32_int32> Createmap_int32_int32Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *keys = nullptr,
    const std::vector<int32_t> *values = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<int32_t>(*keys) : 0;
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return fb::Createmap_int32_int32(
      _fbb,
      keys__,
      values__);
}

::flatbuffers::Offset<map_int32_int32> Createmap_int32_int32(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_int32_int32_int32T : public ::flatbuffers::NativeTable {
  typedef tuple_int32_int32_int32 TableType;
  int32_t item1 = 0;
  int32_t item2 = 0;
  int32_t item3 = 0;
};

struct tuple_int32_int32_int32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_int32_int32_int32T NativeTableType;
  typedef tuple_int32_int32_int32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6,
    VT_ITEM3 = 8
  };
  int32_t item1() const {
    return GetField<int32_t>(VT_ITEM1, 0);
  }
  int32_t item2() const {
    return GetField<int32_t>(VT_ITEM2, 0);
  }
  int32_t item3() const {
    return GetField<int32_t>(VT_ITEM3, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM1, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEM2, 4) &&
           VerifyField<int32_t>(verifier, VT_ITEM3, 4) &&
           verifier.EndTable();
  }
  tuple_int32_int32_int32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_int32_int32_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_int32_int32_int32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_int32_int32_int32Builder {
  typedef tuple_int32_int32_int32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(int32_t item1) {
    fbb_.AddElement<int32_t>(tuple_int32_int32_int32::VT_ITEM1, item1, 0);
  }
  void add_item2(int32_t item2) {
    fbb_.AddElement<int32_t>(tuple_int32_int32_int32::VT_ITEM2, item2, 0);
  }
  void add_item3(int32_t item3) {
    fbb_.AddElement<int32_t>(tuple_int32_int32_int32::VT_ITEM3, item3, 0);
  }
  explicit tuple_int32_int32_int32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_int32_int32_int32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_int32_int32_int32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_int32_int32_int32> Createtuple_int32_int32_int32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    int32_t item2 = 0,
    int32_t item3 = 0) {
  tuple_int32_int32_int32Builder builder_(_fbb);
  builder_.add_item3(item3);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_int32_int32_int32> Createtuple_int32_int32_int32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_int32_string_list_uint32T : public ::flatbuffers::NativeTable {
  typedef tuple_int32_string_list_uint32 TableType;
  int32_t item1 = 0;
  std::string item2{};
  std::vector<uint32_t> item3{};
};

struct tuple_int32_string_list_uint32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_int32_string_list_uint32T NativeTableType;
  typedef tuple_int32_string_list_uint32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6,
    VT_ITEM3 = 8
  };
  int32_t item1() const {
    return GetField<int32_t>(VT_ITEM1, 0);
  }
  const ::flatbuffers::String *item2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ITEM2);
  }
  const ::flatbuffers::Vector<uint32_t> *item3() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ITEM3);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM1, 4) &&
           VerifyOffset(verifier, VT_ITEM2) &&
           verifier.VerifyString(item2()) &&
           VerifyOffset(verifier, VT_ITEM3) &&
           verifier.VerifyVector(item3()) &&
           verifier.EndTable();
  }
  tuple_int32_string_list_uint32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_int32_string_list_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_int32_string_list_uint32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_string_list_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_int32_string_list_uint32Builder {
  typedef tuple_int32_string_list_uint32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(int32_t item1) {
    fbb_.AddElement<int32_t>(tuple_int32_string_list_uint32::VT_ITEM1, item1, 0);
  }
  void add_item2(::flatbuffers::Offset<::flatbuffers::String> item2) {
    fbb_.AddOffset(tuple_int32_string_list_uint32::VT_ITEM2, item2);
  }
  void add_item3(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> item3) {
    fbb_.AddOffset(tuple_int32_string_list_uint32::VT_ITEM3, item3);
  }
  explicit tuple_int32_string_list_uint32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_int32_string_list_uint32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_int32_string_list_uint32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_int32_string_list_uint32> Createtuple_int32_string_list_uint32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> item2 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> item3 = 0) {
  tuple_int32_string_list_uint32Builder builder_(_fbb);
  builder_.add_item3(item3);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<tuple_int32_string_list_uint32> Createtuple_int32_string_list_uint32Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    const char *item2 = nullptr,
    const std::vector<uint32_t> *item3 = nullptr) {
  auto item2__ = item2 ? _fbb.CreateString(item2) : 0;
  auto item3__ = item3 ? _fbb.CreateVector<uint32_t>(*item3) : 0;
  return fb::Createtuple_int32_string_list_uint32(
      _fbb,
      item1,
      item2__,
      item3__);
}

::flatbuffers::Offset<tuple_int32_string_list_uint32> Createtuple_int32_string_list_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_string_list_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct map_int32_int64T : public ::flatbuffers::NativeTable {
  typedef map_int32_int64 TableType;
  std::vector<int32_t> keys{};
  std::vector<int64_t> values{};
};

struct map_int32_int64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef map_int32_int64T NativeTableType;
  typedef map_int32_int64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::Vector<int32_t> *keys() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KEYS);
  }
  const ::flatbuffers::Vector<int64_t> *values() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  map_int32_int64T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(map_int32_int64T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<map_int32_int64> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct map_int32_int64Builder {
  typedef map_int32_int64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keys(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> keys) {
    fbb_.AddOffset(map_int32_int64::VT_KEYS, keys);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> values) {
    fbb_.AddOffset(map_int32_int64::VT_VALUES, values);
  }
  explicit map_int32_int64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<map_int32_int64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<map_int32_int64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<map_int32_int64> Createmap_int32_int64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> keys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> values = 0) {
  map_int32_int64Builder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<map_int32_int64> Createmap_int32_int64Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *keys = nullptr,
    const std::vector<int64_t> *values = nullptr) {
  auto keys__ = keys ? _fbb.CreateVector<int32_t>(*keys) : 0;
  auto values__ = values ? _fbb.CreateVector<int64_t>(*values) : 0;
  return fb::Createmap_int32_int64(
      _fbb,
      keys__,
      values__);
}

::flatbuffers::Offset<map_int32_int64> Createmap_int32_int64(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_int32_tuple_uint32_stringT : public ::flatbuffers::NativeTable {
  typedef tuple_int32_tuple_uint32_string TableType;
  int32_t item1 = 0;
  std::unique_ptr<fb::tuple_uint32_stringT> item2{};
  tuple_int32_tuple_uint32_stringT() = default;
  tuple_int32_tuple_uint32_stringT(const tuple_int32_tuple_uint32_stringT &o);
  tuple_int32_tuple_uint32_stringT(tuple_int32_tuple_uint32_stringT&&) FLATBUFFERS_NOEXCEPT = default;
  tuple_int32_tuple_uint32_stringT &operator=(tuple_int32_tuple_uint32_stringT o) FLATBUFFERS_NOEXCEPT;
};

struct tuple_int32_tuple_uint32_string FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_int32_tuple_uint32_stringT NativeTableType;
  typedef tuple_int32_tuple_uint32_stringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6
  };
  int32_t item1() const {
    return GetField<int32_t>(VT_ITEM1, 0);
  }
  const fb::tuple_uint32_string *item2() const {
    return GetPointer<const fb::tuple_uint32_string *>(VT_ITEM2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ITEM1, 4) &&
           VerifyOffset(verifier, VT_ITEM2) &&
           verifier.VerifyTable(item2()) &&
           verifier.EndTable();
  }
  tuple_int32_tuple_uint32_stringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_int32_tuple_uint32_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_int32_tuple_uint32_string> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_tuple_uint32_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_int32_tuple_uint32_stringBuilder {
  typedef tuple_int32_tuple_uint32_string Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(int32_t item1) {
    fbb_.AddElement<int32_t>(tuple_int32_tuple_uint32_string::VT_ITEM1, item1, 0);
  }
  void add_item2(::flatbuffers::Offset<fb::tuple_uint32_string> item2) {
    fbb_.AddOffset(tuple_int32_tuple_uint32_string::VT_ITEM2, item2);
  }
  explicit tuple_int32_tuple_uint32_stringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_int32_tuple_uint32_string> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_int32_tuple_uint32_string>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_int32_tuple_uint32_string> Createtuple_int32_tuple_uint32_string(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t item1 = 0,
    ::flatbuffers::Offset<fb::tuple_uint32_string> item2 = 0) {
  tuple_int32_tuple_uint32_stringBuilder builder_(_fbb);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

::flatbuffers::Offset<tuple_int32_tuple_uint32_string> Createtuple_int32_tuple_uint32_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_tuple_uint32_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct list_uint32T : public ::flatbuffers::NativeTable {
  typedef list_uint32 TableType;
  std::vector<uint32_t> items{};
};

struct list_uint32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef list_uint32T NativeTableType;
  typedef list_uint32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<uint32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
  list_uint32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(list_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<list_uint32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const list_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct list_uint32Builder {
  typedef list_uint32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> items) {
    fbb_.AddOffset(list_uint32::VT_ITEMS, items);
  }
  explicit list_uint32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<list_uint32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<list_uint32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<list_uint32> Createlist_uint32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> items = 0) {
  list_uint32Builder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<list_uint32> Createlist_uint32Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint32_t>(*items) : 0;
  return fb::Createlist_uint32(
      _fbb,
      items__);
}

::flatbuffers::Offset<list_uint32> Createlist_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const list_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct tuple_uint32_stringT : public ::flatbuffers::NativeTable {
  typedef tuple_uint32_string TableType;
  uint32_t item1 = 0;
  std::string item2{};
};

struct tuple_uint32_string FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef tuple_uint32_stringT NativeTableType;
  typedef tuple_uint32_stringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM1 = 4,
    VT_ITEM2 = 6
  };
  uint32_t item1() const {
    return GetField<uint32_t>(VT_ITEM1, 0);
  }
  const ::flatbuffers::String *item2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ITEM2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ITEM1, 4) &&
           VerifyOffset(verifier, VT_ITEM2) &&
           verifier.VerifyString(item2()) &&
           verifier.EndTable();
  }
  tuple_uint32_stringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(tuple_uint32_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<tuple_uint32_string> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct tuple_uint32_stringBuilder {
  typedef tuple_uint32_string Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_item1(uint32_t item1) {
    fbb_.AddElement<uint32_t>(tuple_uint32_string::VT_ITEM1, item1, 0);
  }
  void add_item2(::flatbuffers::Offset<::flatbuffers::String> item2) {
    fbb_.AddOffset(tuple_uint32_string::VT_ITEM2, item2);
  }
  explicit tuple_uint32_stringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<tuple_uint32_string> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<tuple_uint32_string>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<tuple_uint32_string> Createtuple_uint32_string(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t item1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> item2 = 0) {
  tuple_uint32_stringBuilder builder_(_fbb);
  builder_.add_item2(item2);
  builder_.add_item1(item1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<tuple_uint32_string> Createtuple_uint32_stringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t item1 = 0,
    const char *item2 = nullptr) {
  auto item2__ = item2 ? _fbb.CreateString(item2) : 0;
  return fb::Createtuple_uint32_string(
      _fbb,
      item1,
      item2__);
}

::flatbuffers::Offset<tuple_uint32_string> Createtuple_uint32_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline list_int32T *list_int32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<list_int32T>(new list_int32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void list_int32::UnPackTo(list_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = _e->Get(_i); } } else { _o->items.resize(0); } }
}

inline ::flatbuffers::Offset<list_int32> list_int32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const list_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createlist_int32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<list_int32> Createlist_int32(::flatbuffers::FlatBufferBuilder &_fbb, const list_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const list_int32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _items = _o->items.size() ? _fbb.CreateVector(_o->items) : 0;
  return fb::Createlist_int32(
      _fbb,
      _items);
}

inline tuple_int32_stringT *tuple_int32_string::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_int32_stringT>(new tuple_int32_stringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_int32_string::UnPackTo(tuple_int32_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); if (_e) _o->item2 = _e->str(); }
}

inline ::flatbuffers::Offset<tuple_int32_string> tuple_int32_string::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_int32_string(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_int32_string> Createtuple_int32_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_int32_stringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2.empty() ? 0 : _fbb.CreateString(_o->item2);
  return fb::Createtuple_int32_string(
      _fbb,
      _item1,
      _item2);
}

inline list_stringT *list_string::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<list_stringT>(new list_stringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void list_string::UnPackTo(list_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = _e->Get(_i)->str(); } } else { _o->items.resize(0); } }
}

inline ::flatbuffers::Offset<list_string> list_string::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const list_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createlist_string(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<list_string> Createlist_string(::flatbuffers::FlatBufferBuilder &_fbb, const list_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const list_stringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _items = _o->items.size() ? _fbb.CreateVectorOfStrings(_o->items) : 0;
  return fb::Createlist_string(
      _fbb,
      _items);
}

inline tuple_int32_list_stringT *tuple_int32_list_string::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_int32_list_stringT>(new tuple_int32_list_stringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_int32_list_string::UnPackTo(tuple_int32_list_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); if (_e) { _o->item2.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->item2[_i] = _e->Get(_i)->str(); } } else { _o->item2.resize(0); } }
}

inline ::flatbuffers::Offset<tuple_int32_list_string> tuple_int32_list_string::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_list_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_int32_list_string(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_int32_list_string> Createtuple_int32_list_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_list_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_int32_list_stringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2.size() ? _fbb.CreateVectorOfStrings(_o->item2) : 0;
  return fb::Createtuple_int32_list_string(
      _fbb,
      _item1,
      _item2);
}

inline tuple_uint32_uint32T *tuple_uint32_uint32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_uint32_uint32T>(new tuple_uint32_uint32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_uint32_uint32::UnPackTo(tuple_uint32_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); _o->item2 = _e; }
}

inline ::flatbuffers::Offset<tuple_uint32_uint32> tuple_uint32_uint32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_uint32_uint32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_uint32_uint32> Createtuple_uint32_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_uint32_uint32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2;
  return fb::Createtuple_uint32_uint32(
      _fbb,
      _item1,
      _item2);
}

inline tuple_float32_float32_float32T *tuple_float32_float32_float32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_float32_float32_float32T>(new tuple_float32_float32_float32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_float32_float32_float32::UnPackTo(tuple_float32_float32_float32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); _o->item2 = _e; }
  { auto _e = item3(); _o->item3 = _e; }
}

inline ::flatbuffers::Offset<tuple_float32_float32_float32> tuple_float32_float32_float32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_float32_float32_float32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_float32_float32_float32> Createtuple_float32_float32_float32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_float32_float32_float32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2;
  auto _item3 = _o->item3;
  return fb::Createtuple_float32_float32_float32(
      _fbb,
      _item1,
      _item2,
      _item3);
}

inline tuple_float32_float32_float32_float32T *tuple_float32_float32_float32_float32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_float32_float32_float32_float32T>(new tuple_float32_float32_float32_float32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_float32_float32_float32_float32::UnPackTo(tuple_float32_float32_float32_float32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); _o->item2 = _e; }
  { auto _e = item3(); _o->item3 = _e; }
  { auto _e = item4(); _o->item4 = _e; }
}

inline ::flatbuffers::Offset<tuple_float32_float32_float32_float32> tuple_float32_float32_float32_float32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32_float32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_float32_float32_float32_float32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_float32_float32_float32_float32> Createtuple_float32_float32_float32_float32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_float32_float32_float32_float32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_float32_float32_float32_float32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2;
  auto _item3 = _o->item3;
  auto _item4 = _o->item4;
  return fb::Createtuple_float32_float32_float32_float32(
      _fbb,
      _item1,
      _item2,
      _item3,
      _item4);
}

inline tuple_int32_int32T *tuple_int32_int32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_int32_int32T>(new tuple_int32_int32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_int32_int32::UnPackTo(tuple_int32_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); _o->item2 = _e; }
}

inline ::flatbuffers::Offset<tuple_int32_int32> tuple_int32_int32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_int32_int32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_int32_int32> Createtuple_int32_int32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_int32_int32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2;
  return fb::Createtuple_int32_int32(
      _fbb,
      _item1,
      _item2);
}

inline tuple_uint32_uint32_uint32T *tuple_uint32_uint32_uint32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_uint32_uint32_uint32T>(new tuple_uint32_uint32_uint32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_uint32_uint32_uint32::UnPackTo(tuple_uint32_uint32_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); _o->item2 = _e; }
  { auto _e = item3(); _o->item3 = _e; }
}

inline ::flatbuffers::Offset<tuple_uint32_uint32_uint32> tuple_uint32_uint32_uint32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_uint32_uint32_uint32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_uint32_uint32_uint32> Createtuple_uint32_uint32_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_uint32_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_uint32_uint32_uint32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2;
  auto _item3 = _o->item3;
  return fb::Createtuple_uint32_uint32_uint32(
      _fbb,
      _item1,
      _item2,
      _item3);
}

inline map_int32_int32T *map_int32_int32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<map_int32_int32T>(new map_int32_int32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void map_int32_int32::UnPackTo(map_int32_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keys(); if (_e) { _o->keys.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys[_i] = _e->Get(_i); } } else { _o->keys.resize(0); } }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<map_int32_int32> map_int32_int32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createmap_int32_int32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<map_int32_int32> Createmap_int32_int32(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const map_int32_int32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keys = _o->keys.size() ? _fbb.CreateVector(_o->keys) : 0;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return fb::Createmap_int32_int32(
      _fbb,
      _keys,
      _values);
}

inline tuple_int32_int32_int32T *tuple_int32_int32_int32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_int32_int32_int32T>(new tuple_int32_int32_int32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_int32_int32_int32::UnPackTo(tuple_int32_int32_int32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); _o->item2 = _e; }
  { auto _e = item3(); _o->item3 = _e; }
}

inline ::flatbuffers::Offset<tuple_int32_int32_int32> tuple_int32_int32_int32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32_int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_int32_int32_int32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_int32_int32_int32> Createtuple_int32_int32_int32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_int32_int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_int32_int32_int32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2;
  auto _item3 = _o->item3;
  return fb::Createtuple_int32_int32_int32(
      _fbb,
      _item1,
      _item2,
      _item3);
}

inline tuple_int32_string_list_uint32T *tuple_int32_string_list_uint32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_int32_string_list_uint32T>(new tuple_int32_string_list_uint32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_int32_string_list_uint32::UnPackTo(tuple_int32_string_list_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); if (_e) _o->item2 = _e->str(); }
  { auto _e = item3(); if (_e) { _o->item3.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->item3[_i] = _e->Get(_i); } } else { _o->item3.resize(0); } }
}

inline ::flatbuffers::Offset<tuple_int32_string_list_uint32> tuple_int32_string_list_uint32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_string_list_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_int32_string_list_uint32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_int32_string_list_uint32> Createtuple_int32_string_list_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_string_list_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_int32_string_list_uint32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2.empty() ? 0 : _fbb.CreateString(_o->item2);
  auto _item3 = _o->item3.size() ? _fbb.CreateVector(_o->item3) : 0;
  return fb::Createtuple_int32_string_list_uint32(
      _fbb,
      _item1,
      _item2,
      _item3);
}

inline map_int32_int64T *map_int32_int64::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<map_int32_int64T>(new map_int32_int64T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void map_int32_int64::UnPackTo(map_int32_int64T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keys(); if (_e) { _o->keys.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->keys[_i] = _e->Get(_i); } } else { _o->keys.resize(0); } }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<map_int32_int64> map_int32_int64::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createmap_int32_int64(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<map_int32_int64> Createmap_int32_int64(::flatbuffers::FlatBufferBuilder &_fbb, const map_int32_int64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const map_int32_int64T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keys = _o->keys.size() ? _fbb.CreateVector(_o->keys) : 0;
  auto _values = _o->values.size() ? _fbb.CreateVector(_o->values) : 0;
  return fb::Createmap_int32_int64(
      _fbb,
      _keys,
      _values);
}

inline tuple_int32_tuple_uint32_stringT::tuple_int32_tuple_uint32_stringT(const tuple_int32_tuple_uint32_stringT &o)
      : item1(o.item1),
        item2((o.item2) ? new fb::tuple_uint32_stringT(*o.item2) : nullptr) {
}

inline tuple_int32_tuple_uint32_stringT &tuple_int32_tuple_uint32_stringT::operator=(tuple_int32_tuple_uint32_stringT o) FLATBUFFERS_NOEXCEPT {
  std::swap(item1, o.item1);
  std::swap(item2, o.item2);
  return *this;
}

inline tuple_int32_tuple_uint32_stringT *tuple_int32_tuple_uint32_string::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_int32_tuple_uint32_stringT>(new tuple_int32_tuple_uint32_stringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_int32_tuple_uint32_string::UnPackTo(tuple_int32_tuple_uint32_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); if (_e) { if(_o->item2) { _e->UnPackTo(_o->item2.get(), _resolver); } else { _o->item2 = std::unique_ptr<fb::tuple_uint32_stringT>(_e->UnPack(_resolver)); } } else if (_o->item2) { _o->item2.reset(); } }
}

inline ::flatbuffers::Offset<tuple_int32_tuple_uint32_string> tuple_int32_tuple_uint32_string::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_tuple_uint32_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_int32_tuple_uint32_string(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_int32_tuple_uint32_string> Createtuple_int32_tuple_uint32_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_int32_tuple_uint32_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_int32_tuple_uint32_stringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2 ? Createtuple_uint32_string(_fbb, _o->item2.get(), _rehasher) : 0;
  return fb::Createtuple_int32_tuple_uint32_string(
      _fbb,
      _item1,
      _item2);
}

inline list_uint32T *list_uint32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<list_uint32T>(new list_uint32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void list_uint32::UnPackTo(list_uint32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = _e->Get(_i); } } else { _o->items.resize(0); } }
}

inline ::flatbuffers::Offset<list_uint32> list_uint32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const list_uint32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createlist_uint32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<list_uint32> Createlist_uint32(::flatbuffers::FlatBufferBuilder &_fbb, const list_uint32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const list_uint32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _items = _o->items.size() ? _fbb.CreateVector(_o->items) : 0;
  return fb::Createlist_uint32(
      _fbb,
      _items);
}

inline tuple_uint32_stringT *tuple_uint32_string::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<tuple_uint32_stringT>(new tuple_uint32_stringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void tuple_uint32_string::UnPackTo(tuple_uint32_stringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item1(); _o->item1 = _e; }
  { auto _e = item2(); if (_e) _o->item2 = _e->str(); }
}

inline ::flatbuffers::Offset<tuple_uint32_string> tuple_uint32_string::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_stringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtuple_uint32_string(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<tuple_uint32_string> Createtuple_uint32_string(::flatbuffers::FlatBufferBuilder &_fbb, const tuple_uint32_stringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const tuple_uint32_stringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item1 = _o->item1;
  auto _item2 = _o->item2.empty() ? 0 : _fbb.CreateString(_o->item2);
  return fb::Createtuple_uint32_string(
      _fbb,
      _item1,
      _item2);
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_COMMON_FB_H_

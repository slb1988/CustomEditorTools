// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TASK_FB_H_
#define FLATBUFFERS_GENERATED_TASK_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct Task;
struct TaskBuilder;
struct TaskT;

struct TaskRow;
struct TaskRowBuilder;
struct TaskRowT;

struct TaskT : public ::flatbuffers::NativeTable {
  typedef Task TableType;
  std::vector<std::unique_ptr<fb::TaskRowT>> Tasks{};
  TaskT() = default;
  TaskT(const TaskT &o);
  TaskT(TaskT&&) FLATBUFFERS_NOEXCEPT = default;
  TaskT &operator=(TaskT o) FLATBUFFERS_NOEXCEPT;
};

struct Task FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaskT NativeTableType;
  typedef TaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASKS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::TaskRow>> *Tasks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::TaskRow>> *>(VT_TASKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASKS) &&
           verifier.VerifyVector(Tasks()) &&
           verifier.VerifyVectorOfTables(Tasks()) &&
           verifier.EndTable();
  }
  TaskT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Task> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaskT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaskBuilder {
  typedef Task Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Tasks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::TaskRow>>> Tasks) {
    fbb_.AddOffset(Task::VT_TASKS, Tasks);
  }
  explicit TaskBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Task> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Task>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Task> CreateTask(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::TaskRow>>> Tasks = 0) {
  TaskBuilder builder_(_fbb);
  builder_.add_Tasks(Tasks);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Task> CreateTaskDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<fb::TaskRow>> *Tasks = nullptr) {
  auto Tasks__ = Tasks ? _fbb.CreateVectorOfSortedTables<fb::TaskRow>(Tasks) : 0;
  return fb::CreateTask(
      _fbb,
      Tasks__);
}

::flatbuffers::Offset<Task> CreateTask(::flatbuffers::FlatBufferBuilder &_fbb, const TaskT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaskRowT : public ::flatbuffers::NativeTable {
  typedef TaskRow TableType;
  uint32_t Id = 0;
  fb::TaskType Type = fb::TaskType_NONE;
  std::string Name{};
  uint32_t PreTask = 0;
  uint32_t NextTask = 0;
  uint32_t UnlockConditionGroup = 0;
  uint32_t AcceptConditionGroup = 0;
  std::vector<uint32_t> ProgressConditionGroup{};
  uint32_t LimitMinutes = 0;
  int64_t ShowTime = 0;
  int64_t StartTime = 0;
  int64_t EndTime = 0;
  std::vector<std::unique_ptr<fb::tuple_uint32_uint32_uint32T>> Rewards{};
  uint32_t CompletableTimes = 0;
  bool ShowList = false;
  TaskRowT() = default;
  TaskRowT(const TaskRowT &o);
  TaskRowT(TaskRowT&&) FLATBUFFERS_NOEXCEPT = default;
  TaskRowT &operator=(TaskRowT o) FLATBUFFERS_NOEXCEPT;
};

struct TaskRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaskRowT NativeTableType;
  typedef TaskRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_NAME = 8,
    VT_PRETASK = 10,
    VT_NEXTTASK = 12,
    VT_UNLOCKCONDITIONGROUP = 14,
    VT_ACCEPTCONDITIONGROUP = 16,
    VT_PROGRESSCONDITIONGROUP = 18,
    VT_LIMITMINUTES = 20,
    VT_SHOWTIME = 22,
    VT_STARTTIME = 24,
    VT_ENDTIME = 26,
    VT_REWARDS = 28,
    VT_COMPLETABLETIMES = 30,
    VT_SHOWLIST = 32
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool KeyCompareLessThan(const TaskRow * const o) const {
    return Id() < o->Id();
  }
  int KeyCompareWithValue(uint32_t _Id) const {
    return static_cast<int>(Id() > _Id) - static_cast<int>(Id() < _Id);
  }
  fb::TaskType Type() const {
    return static_cast<fb::TaskType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t PreTask() const {
    return GetField<uint32_t>(VT_PRETASK, 0);
  }
  uint32_t NextTask() const {
    return GetField<uint32_t>(VT_NEXTTASK, 0);
  }
  uint32_t UnlockConditionGroup() const {
    return GetField<uint32_t>(VT_UNLOCKCONDITIONGROUP, 0);
  }
  uint32_t AcceptConditionGroup() const {
    return GetField<uint32_t>(VT_ACCEPTCONDITIONGROUP, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *ProgressConditionGroup() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PROGRESSCONDITIONGROUP);
  }
  uint32_t LimitMinutes() const {
    return GetField<uint32_t>(VT_LIMITMINUTES, 0);
  }
  int64_t ShowTime() const {
    return GetField<int64_t>(VT_SHOWTIME, 0);
  }
  int64_t StartTime() const {
    return GetField<int64_t>(VT_STARTTIME, 0);
  }
  int64_t EndTime() const {
    return GetField<int64_t>(VT_ENDTIME, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>> *Rewards() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>> *>(VT_REWARDS);
  }
  uint32_t CompletableTimes() const {
    return GetField<uint32_t>(VT_COMPLETABLETIMES, 0);
  }
  bool ShowList() const {
    return GetField<uint8_t>(VT_SHOWLIST, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<uint32_t>(verifier, VT_PRETASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_NEXTTASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNLOCKCONDITIONGROUP, 4) &&
           VerifyField<uint32_t>(verifier, VT_ACCEPTCONDITIONGROUP, 4) &&
           VerifyOffset(verifier, VT_PROGRESSCONDITIONGROUP) &&
           verifier.VerifyVector(ProgressConditionGroup()) &&
           VerifyField<uint32_t>(verifier, VT_LIMITMINUTES, 4) &&
           VerifyField<int64_t>(verifier, VT_SHOWTIME, 8) &&
           VerifyField<int64_t>(verifier, VT_STARTTIME, 8) &&
           VerifyField<int64_t>(verifier, VT_ENDTIME, 8) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.VerifyVector(Rewards()) &&
           verifier.VerifyVectorOfTables(Rewards()) &&
           VerifyField<uint32_t>(verifier, VT_COMPLETABLETIMES, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHOWLIST, 1) &&
           verifier.EndTable();
  }
  TaskRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaskRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaskRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaskRowBuilder {
  typedef TaskRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_ID, Id, 0);
  }
  void add_Type(fb::TaskType Type) {
    fbb_.AddElement<int32_t>(TaskRow::VT_TYPE, static_cast<int32_t>(Type), 0);
  }
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(TaskRow::VT_NAME, Name);
  }
  void add_PreTask(uint32_t PreTask) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_PRETASK, PreTask, 0);
  }
  void add_NextTask(uint32_t NextTask) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_NEXTTASK, NextTask, 0);
  }
  void add_UnlockConditionGroup(uint32_t UnlockConditionGroup) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_UNLOCKCONDITIONGROUP, UnlockConditionGroup, 0);
  }
  void add_AcceptConditionGroup(uint32_t AcceptConditionGroup) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_ACCEPTCONDITIONGROUP, AcceptConditionGroup, 0);
  }
  void add_ProgressConditionGroup(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ProgressConditionGroup) {
    fbb_.AddOffset(TaskRow::VT_PROGRESSCONDITIONGROUP, ProgressConditionGroup);
  }
  void add_LimitMinutes(uint32_t LimitMinutes) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_LIMITMINUTES, LimitMinutes, 0);
  }
  void add_ShowTime(int64_t ShowTime) {
    fbb_.AddElement<int64_t>(TaskRow::VT_SHOWTIME, ShowTime, 0);
  }
  void add_StartTime(int64_t StartTime) {
    fbb_.AddElement<int64_t>(TaskRow::VT_STARTTIME, StartTime, 0);
  }
  void add_EndTime(int64_t EndTime) {
    fbb_.AddElement<int64_t>(TaskRow::VT_ENDTIME, EndTime, 0);
  }
  void add_Rewards(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>>> Rewards) {
    fbb_.AddOffset(TaskRow::VT_REWARDS, Rewards);
  }
  void add_CompletableTimes(uint32_t CompletableTimes) {
    fbb_.AddElement<uint32_t>(TaskRow::VT_COMPLETABLETIMES, CompletableTimes, 0);
  }
  void add_ShowList(bool ShowList) {
    fbb_.AddElement<uint8_t>(TaskRow::VT_SHOWLIST, static_cast<uint8_t>(ShowList), 0);
  }
  explicit TaskRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaskRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaskRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TaskRow> CreateTaskRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    fb::TaskType Type = fb::TaskType_NONE,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    uint32_t PreTask = 0,
    uint32_t NextTask = 0,
    uint32_t UnlockConditionGroup = 0,
    uint32_t AcceptConditionGroup = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ProgressConditionGroup = 0,
    uint32_t LimitMinutes = 0,
    int64_t ShowTime = 0,
    int64_t StartTime = 0,
    int64_t EndTime = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>>> Rewards = 0,
    uint32_t CompletableTimes = 0,
    bool ShowList = false) {
  TaskRowBuilder builder_(_fbb);
  builder_.add_EndTime(EndTime);
  builder_.add_StartTime(StartTime);
  builder_.add_ShowTime(ShowTime);
  builder_.add_CompletableTimes(CompletableTimes);
  builder_.add_Rewards(Rewards);
  builder_.add_LimitMinutes(LimitMinutes);
  builder_.add_ProgressConditionGroup(ProgressConditionGroup);
  builder_.add_AcceptConditionGroup(AcceptConditionGroup);
  builder_.add_UnlockConditionGroup(UnlockConditionGroup);
  builder_.add_NextTask(NextTask);
  builder_.add_PreTask(PreTask);
  builder_.add_Name(Name);
  builder_.add_Type(Type);
  builder_.add_Id(Id);
  builder_.add_ShowList(ShowList);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaskRow> CreateTaskRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    fb::TaskType Type = fb::TaskType_NONE,
    const char *Name = nullptr,
    uint32_t PreTask = 0,
    uint32_t NextTask = 0,
    uint32_t UnlockConditionGroup = 0,
    uint32_t AcceptConditionGroup = 0,
    const std::vector<uint32_t> *ProgressConditionGroup = nullptr,
    uint32_t LimitMinutes = 0,
    int64_t ShowTime = 0,
    int64_t StartTime = 0,
    int64_t EndTime = 0,
    const std::vector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>> *Rewards = nullptr,
    uint32_t CompletableTimes = 0,
    bool ShowList = false) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto ProgressConditionGroup__ = ProgressConditionGroup ? _fbb.CreateVector<uint32_t>(*ProgressConditionGroup) : 0;
  auto Rewards__ = Rewards ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>>(*Rewards) : 0;
  return fb::CreateTaskRow(
      _fbb,
      Id,
      Type,
      Name__,
      PreTask,
      NextTask,
      UnlockConditionGroup,
      AcceptConditionGroup,
      ProgressConditionGroup__,
      LimitMinutes,
      ShowTime,
      StartTime,
      EndTime,
      Rewards__,
      CompletableTimes,
      ShowList);
}

::flatbuffers::Offset<TaskRow> CreateTaskRow(::flatbuffers::FlatBufferBuilder &_fbb, const TaskRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TaskT::TaskT(const TaskT &o) {
  Tasks.reserve(o.Tasks.size());
  for (const auto &Tasks_ : o.Tasks) { Tasks.emplace_back((Tasks_) ? new fb::TaskRowT(*Tasks_) : nullptr); }
}

inline TaskT &TaskT::operator=(TaskT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Tasks, o.Tasks);
  return *this;
}

inline TaskT *Task::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaskT>(new TaskT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Task::UnPackTo(TaskT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tasks(); if (_e) { _o->Tasks.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Tasks[_i]) { _e->Get(_i)->UnPackTo(_o->Tasks[_i].get(), _resolver); } else { _o->Tasks[_i] = std::unique_ptr<fb::TaskRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Tasks.resize(0); } }
}

inline ::flatbuffers::Offset<Task> Task::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaskT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTask(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Task> CreateTask(::flatbuffers::FlatBufferBuilder &_fbb, const TaskT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaskT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tasks = _o->Tasks.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::TaskRow>> (_o->Tasks.size(), [](size_t i, _VectorArgs *__va) { return CreateTaskRow(*__va->__fbb, __va->__o->Tasks[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateTask(
      _fbb,
      _Tasks);
}

inline TaskRowT::TaskRowT(const TaskRowT &o)
      : Id(o.Id),
        Type(o.Type),
        Name(o.Name),
        PreTask(o.PreTask),
        NextTask(o.NextTask),
        UnlockConditionGroup(o.UnlockConditionGroup),
        AcceptConditionGroup(o.AcceptConditionGroup),
        ProgressConditionGroup(o.ProgressConditionGroup),
        LimitMinutes(o.LimitMinutes),
        ShowTime(o.ShowTime),
        StartTime(o.StartTime),
        EndTime(o.EndTime),
        CompletableTimes(o.CompletableTimes),
        ShowList(o.ShowList) {
  Rewards.reserve(o.Rewards.size());
  for (const auto &Rewards_ : o.Rewards) { Rewards.emplace_back((Rewards_) ? new fb::tuple_uint32_uint32_uint32T(*Rewards_) : nullptr); }
}

inline TaskRowT &TaskRowT::operator=(TaskRowT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(Type, o.Type);
  std::swap(Name, o.Name);
  std::swap(PreTask, o.PreTask);
  std::swap(NextTask, o.NextTask);
  std::swap(UnlockConditionGroup, o.UnlockConditionGroup);
  std::swap(AcceptConditionGroup, o.AcceptConditionGroup);
  std::swap(ProgressConditionGroup, o.ProgressConditionGroup);
  std::swap(LimitMinutes, o.LimitMinutes);
  std::swap(ShowTime, o.ShowTime);
  std::swap(StartTime, o.StartTime);
  std::swap(EndTime, o.EndTime);
  std::swap(Rewards, o.Rewards);
  std::swap(CompletableTimes, o.CompletableTimes);
  std::swap(ShowList, o.ShowList);
  return *this;
}

inline TaskRowT *TaskRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaskRowT>(new TaskRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaskRow::UnPackTo(TaskRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = Type(); _o->Type = _e; }
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = PreTask(); _o->PreTask = _e; }
  { auto _e = NextTask(); _o->NextTask = _e; }
  { auto _e = UnlockConditionGroup(); _o->UnlockConditionGroup = _e; }
  { auto _e = AcceptConditionGroup(); _o->AcceptConditionGroup = _e; }
  { auto _e = ProgressConditionGroup(); if (_e) { _o->ProgressConditionGroup.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ProgressConditionGroup[_i] = _e->Get(_i); } } else { _o->ProgressConditionGroup.resize(0); } }
  { auto _e = LimitMinutes(); _o->LimitMinutes = _e; }
  { auto _e = ShowTime(); _o->ShowTime = _e; }
  { auto _e = StartTime(); _o->StartTime = _e; }
  { auto _e = EndTime(); _o->EndTime = _e; }
  { auto _e = Rewards(); if (_e) { _o->Rewards.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Rewards[_i]) { _e->Get(_i)->UnPackTo(_o->Rewards[_i].get(), _resolver); } else { _o->Rewards[_i] = std::unique_ptr<fb::tuple_uint32_uint32_uint32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Rewards.resize(0); } }
  { auto _e = CompletableTimes(); _o->CompletableTimes = _e; }
  { auto _e = ShowList(); _o->ShowList = _e; }
}

inline ::flatbuffers::Offset<TaskRow> TaskRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaskRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaskRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaskRow> CreateTaskRow(::flatbuffers::FlatBufferBuilder &_fbb, const TaskRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaskRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _Type = _o->Type;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _PreTask = _o->PreTask;
  auto _NextTask = _o->NextTask;
  auto _UnlockConditionGroup = _o->UnlockConditionGroup;
  auto _AcceptConditionGroup = _o->AcceptConditionGroup;
  auto _ProgressConditionGroup = _o->ProgressConditionGroup.size() ? _fbb.CreateVector(_o->ProgressConditionGroup) : 0;
  auto _LimitMinutes = _o->LimitMinutes;
  auto _ShowTime = _o->ShowTime;
  auto _StartTime = _o->StartTime;
  auto _EndTime = _o->EndTime;
  auto _Rewards = _o->Rewards.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32_uint32>> (_o->Rewards.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_uint32_uint32_uint32(*__va->__fbb, __va->__o->Rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _CompletableTimes = _o->CompletableTimes;
  auto _ShowList = _o->ShowList;
  return fb::CreateTaskRow(
      _fbb,
      _Id,
      _Type,
      _Name,
      _PreTask,
      _NextTask,
      _UnlockConditionGroup,
      _AcceptConditionGroup,
      _ProgressConditionGroup,
      _LimitMinutes,
      _ShowTime,
      _StartTime,
      _EndTime,
      _Rewards,
      _CompletableTimes,
      _ShowList);
}

inline const fb::Task *GetTask(const void *buf) {
  return ::flatbuffers::GetRoot<fb::Task>(buf);
}

inline const fb::Task *GetSizePrefixedTask(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::Task>(buf);
}

inline bool VerifyTaskBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::Task>(nullptr);
}

inline bool VerifySizePrefixedTaskBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::Task>(nullptr);
}

inline void FinishTaskBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Task> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTaskBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Task> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::TaskT> UnPackTask(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::TaskT>(GetTask(buf)->UnPack(res));
}

inline std::unique_ptr<fb::TaskT> UnPackSizePrefixedTask(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::TaskT>(GetSizePrefixedTask(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_TASK_FB_H_

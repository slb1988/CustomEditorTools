// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMAL_FB_H_
#define FLATBUFFERS_GENERATED_ANIMAL_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct Animal;
struct AnimalBuilder;
struct AnimalT;

struct AnimalRow;
struct AnimalRowBuilder;
struct AnimalRowT;

struct AnimalT : public ::flatbuffers::NativeTable {
  typedef Animal TableType;
  std::vector<std::unique_ptr<fb::AnimalRowT>> Animals{};
  AnimalT() = default;
  AnimalT(const AnimalT &o);
  AnimalT(AnimalT&&) FLATBUFFERS_NOEXCEPT = default;
  AnimalT &operator=(AnimalT o) FLATBUFFERS_NOEXCEPT;
};

struct Animal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimalT NativeTableType;
  typedef AnimalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIMALS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalRow>> *Animals() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalRow>> *>(VT_ANIMALS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANIMALS) &&
           verifier.VerifyVector(Animals()) &&
           verifier.VerifyVectorOfTables(Animals()) &&
           verifier.EndTable();
  }
  AnimalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Animal> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimalBuilder {
  typedef Animal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Animals(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalRow>>> Animals) {
    fbb_.AddOffset(Animal::VT_ANIMALS, Animals);
  }
  explicit AnimalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Animal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Animal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Animal> CreateAnimal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalRow>>> Animals = 0) {
  AnimalBuilder builder_(_fbb);
  builder_.add_Animals(Animals);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Animal> CreateAnimalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::AnimalRow>> *Animals = nullptr) {
  auto Animals__ = Animals ? _fbb.CreateVector<::flatbuffers::Offset<fb::AnimalRow>>(*Animals) : 0;
  return fb::CreateAnimal(
      _fbb,
      Animals__);
}

::flatbuffers::Offset<Animal> CreateAnimal(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimalRowT : public ::flatbuffers::NativeTable {
  typedef AnimalRow TableType;
  uint32_t Id = 0;
  std::string Name{};
  uint32_t Level = 0;
  int64_t BornTime = 0;
  int64_t AliveTime = 0;
  float BodyRadius = 0.0f;
  float WalkSpeed = 0.0f;
  float RunSpeed = 0.0f;
  float SprintSpeed = 0.0f;
  float PatrolDistance = 0.0f;
  float AlertAudioRange = 0.0f;
  float AlertVisualRange = 0.0f;
  float AlertVisualAngle = 0.0f;
  uint32_t HighAlertValue = 0;
  int64_t CalmMaxDuration = 0;
  uint32_t ResReleaseVer = 0;
  float EscapeDistance = 0.0f;
  int64_t EscapeExitAlertTime = 0;
  uint32_t SkillId = 0;
  int64_t AttackMaxDuration = 0;
  int64_t WaitToAttackTime = 0;
  uint32_t GainExp = 0;
  float LevelCureFactor = 0.0f;
};

struct AnimalRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimalRowT NativeTableType;
  typedef AnimalRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_BORNTIME = 10,
    VT_ALIVETIME = 12,
    VT_BODYRADIUS = 14,
    VT_WALKSPEED = 16,
    VT_RUNSPEED = 18,
    VT_SPRINTSPEED = 20,
    VT_PATROLDISTANCE = 22,
    VT_ALERTAUDIORANGE = 24,
    VT_ALERTVISUALRANGE = 26,
    VT_ALERTVISUALANGLE = 28,
    VT_HIGHALERTVALUE = 30,
    VT_CALMMAXDURATION = 32,
    VT_RESRELEASEVER = 34,
    VT_ESCAPEDISTANCE = 36,
    VT_ESCAPEEXITALERTTIME = 38,
    VT_SKILLID = 40,
    VT_ATTACKMAXDURATION = 42,
    VT_WAITTOATTACKTIME = 44,
    VT_GAINEXP = 46,
    VT_LEVELCUREFACTOR = 48
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t Level() const {
    return GetField<uint32_t>(VT_LEVEL, 0);
  }
  int64_t BornTime() const {
    return GetField<int64_t>(VT_BORNTIME, 0);
  }
  int64_t AliveTime() const {
    return GetField<int64_t>(VT_ALIVETIME, 0);
  }
  float BodyRadius() const {
    return GetField<float>(VT_BODYRADIUS, 0.0f);
  }
  float WalkSpeed() const {
    return GetField<float>(VT_WALKSPEED, 0.0f);
  }
  float RunSpeed() const {
    return GetField<float>(VT_RUNSPEED, 0.0f);
  }
  float SprintSpeed() const {
    return GetField<float>(VT_SPRINTSPEED, 0.0f);
  }
  float PatrolDistance() const {
    return GetField<float>(VT_PATROLDISTANCE, 0.0f);
  }
  float AlertAudioRange() const {
    return GetField<float>(VT_ALERTAUDIORANGE, 0.0f);
  }
  float AlertVisualRange() const {
    return GetField<float>(VT_ALERTVISUALRANGE, 0.0f);
  }
  float AlertVisualAngle() const {
    return GetField<float>(VT_ALERTVISUALANGLE, 0.0f);
  }
  uint32_t HighAlertValue() const {
    return GetField<uint32_t>(VT_HIGHALERTVALUE, 0);
  }
  int64_t CalmMaxDuration() const {
    return GetField<int64_t>(VT_CALMMAXDURATION, 0);
  }
  uint32_t ResReleaseVer() const {
    return GetField<uint32_t>(VT_RESRELEASEVER, 0);
  }
  float EscapeDistance() const {
    return GetField<float>(VT_ESCAPEDISTANCE, 0.0f);
  }
  int64_t EscapeExitAlertTime() const {
    return GetField<int64_t>(VT_ESCAPEEXITALERTTIME, 0);
  }
  uint32_t SkillId() const {
    return GetField<uint32_t>(VT_SKILLID, 0);
  }
  int64_t AttackMaxDuration() const {
    return GetField<int64_t>(VT_ATTACKMAXDURATION, 0);
  }
  int64_t WaitToAttackTime() const {
    return GetField<int64_t>(VT_WAITTOATTACKTIME, 0);
  }
  uint32_t GainExp() const {
    return GetField<uint32_t>(VT_GAINEXP, 0);
  }
  float LevelCureFactor() const {
    return GetField<float>(VT_LEVELCUREFACTOR, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyField<uint32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<int64_t>(verifier, VT_BORNTIME, 8) &&
           VerifyField<int64_t>(verifier, VT_ALIVETIME, 8) &&
           VerifyField<float>(verifier, VT_BODYRADIUS, 4) &&
           VerifyField<float>(verifier, VT_WALKSPEED, 4) &&
           VerifyField<float>(verifier, VT_RUNSPEED, 4) &&
           VerifyField<float>(verifier, VT_SPRINTSPEED, 4) &&
           VerifyField<float>(verifier, VT_PATROLDISTANCE, 4) &&
           VerifyField<float>(verifier, VT_ALERTAUDIORANGE, 4) &&
           VerifyField<float>(verifier, VT_ALERTVISUALRANGE, 4) &&
           VerifyField<float>(verifier, VT_ALERTVISUALANGLE, 4) &&
           VerifyField<uint32_t>(verifier, VT_HIGHALERTVALUE, 4) &&
           VerifyField<int64_t>(verifier, VT_CALMMAXDURATION, 8) &&
           VerifyField<uint32_t>(verifier, VT_RESRELEASEVER, 4) &&
           VerifyField<float>(verifier, VT_ESCAPEDISTANCE, 4) &&
           VerifyField<int64_t>(verifier, VT_ESCAPEEXITALERTTIME, 8) &&
           VerifyField<uint32_t>(verifier, VT_SKILLID, 4) &&
           VerifyField<int64_t>(verifier, VT_ATTACKMAXDURATION, 8) &&
           VerifyField<int64_t>(verifier, VT_WAITTOATTACKTIME, 8) &&
           VerifyField<uint32_t>(verifier, VT_GAINEXP, 4) &&
           VerifyField<float>(verifier, VT_LEVELCUREFACTOR, 4) &&
           verifier.EndTable();
  }
  AnimalRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimalRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AnimalRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimalRowBuilder {
  typedef AnimalRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(AnimalRow::VT_ID, Id, 0);
  }
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(AnimalRow::VT_NAME, Name);
  }
  void add_Level(uint32_t Level) {
    fbb_.AddElement<uint32_t>(AnimalRow::VT_LEVEL, Level, 0);
  }
  void add_BornTime(int64_t BornTime) {
    fbb_.AddElement<int64_t>(AnimalRow::VT_BORNTIME, BornTime, 0);
  }
  void add_AliveTime(int64_t AliveTime) {
    fbb_.AddElement<int64_t>(AnimalRow::VT_ALIVETIME, AliveTime, 0);
  }
  void add_BodyRadius(float BodyRadius) {
    fbb_.AddElement<float>(AnimalRow::VT_BODYRADIUS, BodyRadius, 0.0f);
  }
  void add_WalkSpeed(float WalkSpeed) {
    fbb_.AddElement<float>(AnimalRow::VT_WALKSPEED, WalkSpeed, 0.0f);
  }
  void add_RunSpeed(float RunSpeed) {
    fbb_.AddElement<float>(AnimalRow::VT_RUNSPEED, RunSpeed, 0.0f);
  }
  void add_SprintSpeed(float SprintSpeed) {
    fbb_.AddElement<float>(AnimalRow::VT_SPRINTSPEED, SprintSpeed, 0.0f);
  }
  void add_PatrolDistance(float PatrolDistance) {
    fbb_.AddElement<float>(AnimalRow::VT_PATROLDISTANCE, PatrolDistance, 0.0f);
  }
  void add_AlertAudioRange(float AlertAudioRange) {
    fbb_.AddElement<float>(AnimalRow::VT_ALERTAUDIORANGE, AlertAudioRange, 0.0f);
  }
  void add_AlertVisualRange(float AlertVisualRange) {
    fbb_.AddElement<float>(AnimalRow::VT_ALERTVISUALRANGE, AlertVisualRange, 0.0f);
  }
  void add_AlertVisualAngle(float AlertVisualAngle) {
    fbb_.AddElement<float>(AnimalRow::VT_ALERTVISUALANGLE, AlertVisualAngle, 0.0f);
  }
  void add_HighAlertValue(uint32_t HighAlertValue) {
    fbb_.AddElement<uint32_t>(AnimalRow::VT_HIGHALERTVALUE, HighAlertValue, 0);
  }
  void add_CalmMaxDuration(int64_t CalmMaxDuration) {
    fbb_.AddElement<int64_t>(AnimalRow::VT_CALMMAXDURATION, CalmMaxDuration, 0);
  }
  void add_ResReleaseVer(uint32_t ResReleaseVer) {
    fbb_.AddElement<uint32_t>(AnimalRow::VT_RESRELEASEVER, ResReleaseVer, 0);
  }
  void add_EscapeDistance(float EscapeDistance) {
    fbb_.AddElement<float>(AnimalRow::VT_ESCAPEDISTANCE, EscapeDistance, 0.0f);
  }
  void add_EscapeExitAlertTime(int64_t EscapeExitAlertTime) {
    fbb_.AddElement<int64_t>(AnimalRow::VT_ESCAPEEXITALERTTIME, EscapeExitAlertTime, 0);
  }
  void add_SkillId(uint32_t SkillId) {
    fbb_.AddElement<uint32_t>(AnimalRow::VT_SKILLID, SkillId, 0);
  }
  void add_AttackMaxDuration(int64_t AttackMaxDuration) {
    fbb_.AddElement<int64_t>(AnimalRow::VT_ATTACKMAXDURATION, AttackMaxDuration, 0);
  }
  void add_WaitToAttackTime(int64_t WaitToAttackTime) {
    fbb_.AddElement<int64_t>(AnimalRow::VT_WAITTOATTACKTIME, WaitToAttackTime, 0);
  }
  void add_GainExp(uint32_t GainExp) {
    fbb_.AddElement<uint32_t>(AnimalRow::VT_GAINEXP, GainExp, 0);
  }
  void add_LevelCureFactor(float LevelCureFactor) {
    fbb_.AddElement<float>(AnimalRow::VT_LEVELCUREFACTOR, LevelCureFactor, 0.0f);
  }
  explicit AnimalRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimalRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimalRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimalRow> CreateAnimalRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    uint32_t Level = 0,
    int64_t BornTime = 0,
    int64_t AliveTime = 0,
    float BodyRadius = 0.0f,
    float WalkSpeed = 0.0f,
    float RunSpeed = 0.0f,
    float SprintSpeed = 0.0f,
    float PatrolDistance = 0.0f,
    float AlertAudioRange = 0.0f,
    float AlertVisualRange = 0.0f,
    float AlertVisualAngle = 0.0f,
    uint32_t HighAlertValue = 0,
    int64_t CalmMaxDuration = 0,
    uint32_t ResReleaseVer = 0,
    float EscapeDistance = 0.0f,
    int64_t EscapeExitAlertTime = 0,
    uint32_t SkillId = 0,
    int64_t AttackMaxDuration = 0,
    int64_t WaitToAttackTime = 0,
    uint32_t GainExp = 0,
    float LevelCureFactor = 0.0f) {
  AnimalRowBuilder builder_(_fbb);
  builder_.add_WaitToAttackTime(WaitToAttackTime);
  builder_.add_AttackMaxDuration(AttackMaxDuration);
  builder_.add_EscapeExitAlertTime(EscapeExitAlertTime);
  builder_.add_CalmMaxDuration(CalmMaxDuration);
  builder_.add_AliveTime(AliveTime);
  builder_.add_BornTime(BornTime);
  builder_.add_LevelCureFactor(LevelCureFactor);
  builder_.add_GainExp(GainExp);
  builder_.add_SkillId(SkillId);
  builder_.add_EscapeDistance(EscapeDistance);
  builder_.add_ResReleaseVer(ResReleaseVer);
  builder_.add_HighAlertValue(HighAlertValue);
  builder_.add_AlertVisualAngle(AlertVisualAngle);
  builder_.add_AlertVisualRange(AlertVisualRange);
  builder_.add_AlertAudioRange(AlertAudioRange);
  builder_.add_PatrolDistance(PatrolDistance);
  builder_.add_SprintSpeed(SprintSpeed);
  builder_.add_RunSpeed(RunSpeed);
  builder_.add_WalkSpeed(WalkSpeed);
  builder_.add_BodyRadius(BodyRadius);
  builder_.add_Level(Level);
  builder_.add_Name(Name);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimalRow> CreateAnimalRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    const char *Name = nullptr,
    uint32_t Level = 0,
    int64_t BornTime = 0,
    int64_t AliveTime = 0,
    float BodyRadius = 0.0f,
    float WalkSpeed = 0.0f,
    float RunSpeed = 0.0f,
    float SprintSpeed = 0.0f,
    float PatrolDistance = 0.0f,
    float AlertAudioRange = 0.0f,
    float AlertVisualRange = 0.0f,
    float AlertVisualAngle = 0.0f,
    uint32_t HighAlertValue = 0,
    int64_t CalmMaxDuration = 0,
    uint32_t ResReleaseVer = 0,
    float EscapeDistance = 0.0f,
    int64_t EscapeExitAlertTime = 0,
    uint32_t SkillId = 0,
    int64_t AttackMaxDuration = 0,
    int64_t WaitToAttackTime = 0,
    uint32_t GainExp = 0,
    float LevelCureFactor = 0.0f) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  return fb::CreateAnimalRow(
      _fbb,
      Id,
      Name__,
      Level,
      BornTime,
      AliveTime,
      BodyRadius,
      WalkSpeed,
      RunSpeed,
      SprintSpeed,
      PatrolDistance,
      AlertAudioRange,
      AlertVisualRange,
      AlertVisualAngle,
      HighAlertValue,
      CalmMaxDuration,
      ResReleaseVer,
      EscapeDistance,
      EscapeExitAlertTime,
      SkillId,
      AttackMaxDuration,
      WaitToAttackTime,
      GainExp,
      LevelCureFactor);
}

::flatbuffers::Offset<AnimalRow> CreateAnimalRow(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AnimalT::AnimalT(const AnimalT &o) {
  Animals.reserve(o.Animals.size());
  for (const auto &Animals_ : o.Animals) { Animals.emplace_back((Animals_) ? new fb::AnimalRowT(*Animals_) : nullptr); }
}

inline AnimalT &AnimalT::operator=(AnimalT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Animals, o.Animals);
  return *this;
}

inline AnimalT *Animal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimalT>(new AnimalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Animal::UnPackTo(AnimalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Animals(); if (_e) { _o->Animals.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Animals[_i]) { _e->Get(_i)->UnPackTo(_o->Animals[_i].get(), _resolver); } else { _o->Animals[_i] = std::unique_ptr<fb::AnimalRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Animals.resize(0); } }
}

inline ::flatbuffers::Offset<Animal> Animal::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimal(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Animal> CreateAnimal(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AnimalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Animals = _o->Animals.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::AnimalRow>> (_o->Animals.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimalRow(*__va->__fbb, __va->__o->Animals[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateAnimal(
      _fbb,
      _Animals);
}

inline AnimalRowT *AnimalRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimalRowT>(new AnimalRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimalRow::UnPackTo(AnimalRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = Name(); if (_e) _o->Name = _e->str(); }
  { auto _e = Level(); _o->Level = _e; }
  { auto _e = BornTime(); _o->BornTime = _e; }
  { auto _e = AliveTime(); _o->AliveTime = _e; }
  { auto _e = BodyRadius(); _o->BodyRadius = _e; }
  { auto _e = WalkSpeed(); _o->WalkSpeed = _e; }
  { auto _e = RunSpeed(); _o->RunSpeed = _e; }
  { auto _e = SprintSpeed(); _o->SprintSpeed = _e; }
  { auto _e = PatrolDistance(); _o->PatrolDistance = _e; }
  { auto _e = AlertAudioRange(); _o->AlertAudioRange = _e; }
  { auto _e = AlertVisualRange(); _o->AlertVisualRange = _e; }
  { auto _e = AlertVisualAngle(); _o->AlertVisualAngle = _e; }
  { auto _e = HighAlertValue(); _o->HighAlertValue = _e; }
  { auto _e = CalmMaxDuration(); _o->CalmMaxDuration = _e; }
  { auto _e = ResReleaseVer(); _o->ResReleaseVer = _e; }
  { auto _e = EscapeDistance(); _o->EscapeDistance = _e; }
  { auto _e = EscapeExitAlertTime(); _o->EscapeExitAlertTime = _e; }
  { auto _e = SkillId(); _o->SkillId = _e; }
  { auto _e = AttackMaxDuration(); _o->AttackMaxDuration = _e; }
  { auto _e = WaitToAttackTime(); _o->WaitToAttackTime = _e; }
  { auto _e = GainExp(); _o->GainExp = _e; }
  { auto _e = LevelCureFactor(); _o->LevelCureFactor = _e; }
}

inline ::flatbuffers::Offset<AnimalRow> AnimalRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimalRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AnimalRow> CreateAnimalRow(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AnimalRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _Name = _o->Name.empty() ? 0 : _fbb.CreateString(_o->Name);
  auto _Level = _o->Level;
  auto _BornTime = _o->BornTime;
  auto _AliveTime = _o->AliveTime;
  auto _BodyRadius = _o->BodyRadius;
  auto _WalkSpeed = _o->WalkSpeed;
  auto _RunSpeed = _o->RunSpeed;
  auto _SprintSpeed = _o->SprintSpeed;
  auto _PatrolDistance = _o->PatrolDistance;
  auto _AlertAudioRange = _o->AlertAudioRange;
  auto _AlertVisualRange = _o->AlertVisualRange;
  auto _AlertVisualAngle = _o->AlertVisualAngle;
  auto _HighAlertValue = _o->HighAlertValue;
  auto _CalmMaxDuration = _o->CalmMaxDuration;
  auto _ResReleaseVer = _o->ResReleaseVer;
  auto _EscapeDistance = _o->EscapeDistance;
  auto _EscapeExitAlertTime = _o->EscapeExitAlertTime;
  auto _SkillId = _o->SkillId;
  auto _AttackMaxDuration = _o->AttackMaxDuration;
  auto _WaitToAttackTime = _o->WaitToAttackTime;
  auto _GainExp = _o->GainExp;
  auto _LevelCureFactor = _o->LevelCureFactor;
  return fb::CreateAnimalRow(
      _fbb,
      _Id,
      _Name,
      _Level,
      _BornTime,
      _AliveTime,
      _BodyRadius,
      _WalkSpeed,
      _RunSpeed,
      _SprintSpeed,
      _PatrolDistance,
      _AlertAudioRange,
      _AlertVisualRange,
      _AlertVisualAngle,
      _HighAlertValue,
      _CalmMaxDuration,
      _ResReleaseVer,
      _EscapeDistance,
      _EscapeExitAlertTime,
      _SkillId,
      _AttackMaxDuration,
      _WaitToAttackTime,
      _GainExp,
      _LevelCureFactor);
}

inline const fb::Animal *GetAnimal(const void *buf) {
  return ::flatbuffers::GetRoot<fb::Animal>(buf);
}

inline const fb::Animal *GetSizePrefixedAnimal(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::Animal>(buf);
}

inline bool VerifyAnimalBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::Animal>(nullptr);
}

inline bool VerifySizePrefixedAnimalBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::Animal>(nullptr);
}

inline void FinishAnimalBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Animal> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAnimalBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Animal> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::AnimalT> UnPackAnimal(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::AnimalT>(GetAnimal(buf)->UnPack(res));
}

inline std::unique_ptr<fb::AnimalT> UnPackSizePrefixedAnimal(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::AnimalT>(GetSizePrefixedAnimal(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ANIMAL_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SKILL_FB_H_
#define FLATBUFFERS_GENERATED_SKILL_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct Skill;
struct SkillBuilder;
struct SkillT;

struct SkillRow;
struct SkillRowBuilder;
struct SkillRowT;

struct SkillT : public ::flatbuffers::NativeTable {
  typedef Skill TableType;
  std::vector<std::unique_ptr<fb::SkillRowT>> Skills{};
  SkillT() = default;
  SkillT(const SkillT &o);
  SkillT(SkillT&&) FLATBUFFERS_NOEXCEPT = default;
  SkillT &operator=(SkillT o) FLATBUFFERS_NOEXCEPT;
};

struct Skill FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkillT NativeTableType;
  typedef SkillBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKILLS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::SkillRow>> *Skills() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::SkillRow>> *>(VT_SKILLS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.VerifyVector(Skills()) &&
           verifier.VerifyVectorOfTables(Skills()) &&
           verifier.EndTable();
  }
  SkillT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkillT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Skill> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkillT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkillBuilder {
  typedef Skill Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Skills(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::SkillRow>>> Skills) {
    fbb_.AddOffset(Skill::VT_SKILLS, Skills);
  }
  explicit SkillBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Skill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Skill>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Skill> CreateSkill(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::SkillRow>>> Skills = 0) {
  SkillBuilder builder_(_fbb);
  builder_.add_Skills(Skills);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Skill> CreateSkillDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<fb::SkillRow>> *Skills = nullptr) {
  auto Skills__ = Skills ? _fbb.CreateVectorOfSortedTables<fb::SkillRow>(Skills) : 0;
  return fb::CreateSkill(
      _fbb,
      Skills__);
}

::flatbuffers::Offset<Skill> CreateSkill(::flatbuffers::FlatBufferBuilder &_fbb, const SkillT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkillRowT : public ::flatbuffers::NativeTable {
  typedef SkillRow TableType;
  uint32_t Id = 0;
  fb::SkillType Type = fb::SkillType_NONE;
  uint32_t Level = 0;
  int64_t ReleaseInterval = 0;
  uint32_t ReleaseCost = 0;
  uint32_t AssistAddition = 0;
  int64_t StateDuration = 0;
  uint32_t Attack = 0;
};

struct SkillRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkillRowT NativeTableType;
  typedef SkillRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_LEVEL = 8,
    VT_RELEASEINTERVAL = 10,
    VT_RELEASECOST = 12,
    VT_ASSISTADDITION = 14,
    VT_STATEDURATION = 16,
    VT_ATTACK = 18
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool KeyCompareLessThan(const SkillRow * const o) const {
    return Id() < o->Id();
  }
  int KeyCompareWithValue(uint32_t _Id) const {
    return static_cast<int>(Id() > _Id) - static_cast<int>(Id() < _Id);
  }
  fb::SkillType Type() const {
    return static_cast<fb::SkillType>(GetField<int32_t>(VT_TYPE, 0));
  }
  uint32_t Level() const {
    return GetField<uint32_t>(VT_LEVEL, 0);
  }
  int64_t ReleaseInterval() const {
    return GetField<int64_t>(VT_RELEASEINTERVAL, 0);
  }
  uint32_t ReleaseCost() const {
    return GetField<uint32_t>(VT_RELEASECOST, 0);
  }
  uint32_t AssistAddition() const {
    return GetField<uint32_t>(VT_ASSISTADDITION, 0);
  }
  int64_t StateDuration() const {
    return GetField<int64_t>(VT_STATEDURATION, 0);
  }
  uint32_t Attack() const {
    return GetField<uint32_t>(VT_ATTACK, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_LEVEL, 4) &&
           VerifyField<int64_t>(verifier, VT_RELEASEINTERVAL, 8) &&
           VerifyField<uint32_t>(verifier, VT_RELEASECOST, 4) &&
           VerifyField<uint32_t>(verifier, VT_ASSISTADDITION, 4) &&
           VerifyField<int64_t>(verifier, VT_STATEDURATION, 8) &&
           VerifyField<uint32_t>(verifier, VT_ATTACK, 4) &&
           verifier.EndTable();
  }
  SkillRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkillRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SkillRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkillRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkillRowBuilder {
  typedef SkillRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(SkillRow::VT_ID, Id, 0);
  }
  void add_Type(fb::SkillType Type) {
    fbb_.AddElement<int32_t>(SkillRow::VT_TYPE, static_cast<int32_t>(Type), 0);
  }
  void add_Level(uint32_t Level) {
    fbb_.AddElement<uint32_t>(SkillRow::VT_LEVEL, Level, 0);
  }
  void add_ReleaseInterval(int64_t ReleaseInterval) {
    fbb_.AddElement<int64_t>(SkillRow::VT_RELEASEINTERVAL, ReleaseInterval, 0);
  }
  void add_ReleaseCost(uint32_t ReleaseCost) {
    fbb_.AddElement<uint32_t>(SkillRow::VT_RELEASECOST, ReleaseCost, 0);
  }
  void add_AssistAddition(uint32_t AssistAddition) {
    fbb_.AddElement<uint32_t>(SkillRow::VT_ASSISTADDITION, AssistAddition, 0);
  }
  void add_StateDuration(int64_t StateDuration) {
    fbb_.AddElement<int64_t>(SkillRow::VT_STATEDURATION, StateDuration, 0);
  }
  void add_Attack(uint32_t Attack) {
    fbb_.AddElement<uint32_t>(SkillRow::VT_ATTACK, Attack, 0);
  }
  explicit SkillRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkillRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkillRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkillRow> CreateSkillRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    fb::SkillType Type = fb::SkillType_NONE,
    uint32_t Level = 0,
    int64_t ReleaseInterval = 0,
    uint32_t ReleaseCost = 0,
    uint32_t AssistAddition = 0,
    int64_t StateDuration = 0,
    uint32_t Attack = 0) {
  SkillRowBuilder builder_(_fbb);
  builder_.add_StateDuration(StateDuration);
  builder_.add_ReleaseInterval(ReleaseInterval);
  builder_.add_Attack(Attack);
  builder_.add_AssistAddition(AssistAddition);
  builder_.add_ReleaseCost(ReleaseCost);
  builder_.add_Level(Level);
  builder_.add_Type(Type);
  builder_.add_Id(Id);
  return builder_.Finish();
}

::flatbuffers::Offset<SkillRow> CreateSkillRow(::flatbuffers::FlatBufferBuilder &_fbb, const SkillRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SkillT::SkillT(const SkillT &o) {
  Skills.reserve(o.Skills.size());
  for (const auto &Skills_ : o.Skills) { Skills.emplace_back((Skills_) ? new fb::SkillRowT(*Skills_) : nullptr); }
}

inline SkillT &SkillT::operator=(SkillT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Skills, o.Skills);
  return *this;
}

inline SkillT *Skill::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SkillT>(new SkillT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Skill::UnPackTo(SkillT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Skills(); if (_e) { _o->Skills.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Skills[_i]) { _e->Get(_i)->UnPackTo(_o->Skills[_i].get(), _resolver); } else { _o->Skills[_i] = std::unique_ptr<fb::SkillRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Skills.resize(0); } }
}

inline ::flatbuffers::Offset<Skill> Skill::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkillT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkill(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Skill> CreateSkill(::flatbuffers::FlatBufferBuilder &_fbb, const SkillT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SkillT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Skills = _o->Skills.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::SkillRow>> (_o->Skills.size(), [](size_t i, _VectorArgs *__va) { return CreateSkillRow(*__va->__fbb, __va->__o->Skills[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateSkill(
      _fbb,
      _Skills);
}

inline SkillRowT *SkillRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SkillRowT>(new SkillRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SkillRow::UnPackTo(SkillRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = Type(); _o->Type = _e; }
  { auto _e = Level(); _o->Level = _e; }
  { auto _e = ReleaseInterval(); _o->ReleaseInterval = _e; }
  { auto _e = ReleaseCost(); _o->ReleaseCost = _e; }
  { auto _e = AssistAddition(); _o->AssistAddition = _e; }
  { auto _e = StateDuration(); _o->StateDuration = _e; }
  { auto _e = Attack(); _o->Attack = _e; }
}

inline ::flatbuffers::Offset<SkillRow> SkillRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SkillRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkillRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SkillRow> CreateSkillRow(::flatbuffers::FlatBufferBuilder &_fbb, const SkillRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SkillRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _Type = _o->Type;
  auto _Level = _o->Level;
  auto _ReleaseInterval = _o->ReleaseInterval;
  auto _ReleaseCost = _o->ReleaseCost;
  auto _AssistAddition = _o->AssistAddition;
  auto _StateDuration = _o->StateDuration;
  auto _Attack = _o->Attack;
  return fb::CreateSkillRow(
      _fbb,
      _Id,
      _Type,
      _Level,
      _ReleaseInterval,
      _ReleaseCost,
      _AssistAddition,
      _StateDuration,
      _Attack);
}

inline const fb::Skill *GetSkill(const void *buf) {
  return ::flatbuffers::GetRoot<fb::Skill>(buf);
}

inline const fb::Skill *GetSizePrefixedSkill(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::Skill>(buf);
}

inline bool VerifySkillBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::Skill>(nullptr);
}

inline bool VerifySizePrefixedSkillBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::Skill>(nullptr);
}

inline void FinishSkillBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Skill> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSkillBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::Skill> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::SkillT> UnPackSkill(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::SkillT>(GetSkill(buf)->UnPack(res));
}

inline std::unique_ptr<fb::SkillT> UnPackSizePrefixedSkill(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::SkillT>(GetSizePrefixedSkill(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SKILL_FB_H_

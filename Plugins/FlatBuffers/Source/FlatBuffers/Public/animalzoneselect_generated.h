// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMALZONESELECT_FB_H_
#define FLATBUFFERS_GENERATED_ANIMALZONESELECT_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct AnimalZoneSelect;
struct AnimalZoneSelectBuilder;
struct AnimalZoneSelectT;

struct AnimalZoneSelectRow;
struct AnimalZoneSelectRowBuilder;
struct AnimalZoneSelectRowT;

struct AnimalZoneSelectT : public ::flatbuffers::NativeTable {
  typedef AnimalZoneSelect TableType;
  std::vector<std::unique_ptr<fb::AnimalZoneSelectRowT>> AnimalZoneSelects{};
  AnimalZoneSelectT() = default;
  AnimalZoneSelectT(const AnimalZoneSelectT &o);
  AnimalZoneSelectT(AnimalZoneSelectT&&) FLATBUFFERS_NOEXCEPT = default;
  AnimalZoneSelectT &operator=(AnimalZoneSelectT o) FLATBUFFERS_NOEXCEPT;
};

struct AnimalZoneSelect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimalZoneSelectT NativeTableType;
  typedef AnimalZoneSelectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIMALZONESELECTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>> *AnimalZoneSelects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>> *>(VT_ANIMALZONESELECTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANIMALZONESELECTS) &&
           verifier.VerifyVector(AnimalZoneSelects()) &&
           verifier.VerifyVectorOfTables(AnimalZoneSelects()) &&
           verifier.EndTable();
  }
  AnimalZoneSelectT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimalZoneSelectT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AnimalZoneSelect> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimalZoneSelectBuilder {
  typedef AnimalZoneSelect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_AnimalZoneSelects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>>> AnimalZoneSelects) {
    fbb_.AddOffset(AnimalZoneSelect::VT_ANIMALZONESELECTS, AnimalZoneSelects);
  }
  explicit AnimalZoneSelectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimalZoneSelect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimalZoneSelect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimalZoneSelect> CreateAnimalZoneSelect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>>> AnimalZoneSelects = 0) {
  AnimalZoneSelectBuilder builder_(_fbb);
  builder_.add_AnimalZoneSelects(AnimalZoneSelects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimalZoneSelect> CreateAnimalZoneSelectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>> *AnimalZoneSelects = nullptr) {
  auto AnimalZoneSelects__ = AnimalZoneSelects ? _fbb.CreateVector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>>(*AnimalZoneSelects) : 0;
  return fb::CreateAnimalZoneSelect(
      _fbb,
      AnimalZoneSelects__);
}

::flatbuffers::Offset<AnimalZoneSelect> CreateAnimalZoneSelect(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimalZoneSelectRowT : public ::flatbuffers::NativeTable {
  typedef AnimalZoneSelectRow TableType;
  uint32_t Id = 0;
  uint32_t AnimalZoneId = 0;
  std::string RefreshTime{};
  fb::Weather Weather = fb::Weather_NONE;
  uint32_t Priority = 0;
  std::vector<std::unique_ptr<fb::tuple_uint32_uint32T>> Choose{};
  AnimalZoneSelectRowT() = default;
  AnimalZoneSelectRowT(const AnimalZoneSelectRowT &o);
  AnimalZoneSelectRowT(AnimalZoneSelectRowT&&) FLATBUFFERS_NOEXCEPT = default;
  AnimalZoneSelectRowT &operator=(AnimalZoneSelectRowT o) FLATBUFFERS_NOEXCEPT;
};

struct AnimalZoneSelectRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimalZoneSelectRowT NativeTableType;
  typedef AnimalZoneSelectRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ANIMALZONEID = 6,
    VT_REFRESHTIME = 8,
    VT_WEATHER = 10,
    VT_PRIORITY = 12,
    VT_CHOOSE = 14
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t AnimalZoneId() const {
    return GetField<uint32_t>(VT_ANIMALZONEID, 0);
  }
  const ::flatbuffers::String *RefreshTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFRESHTIME);
  }
  fb::Weather Weather() const {
    return static_cast<fb::Weather>(GetField<int32_t>(VT_WEATHER, 0));
  }
  uint32_t Priority() const {
    return GetField<uint32_t>(VT_PRIORITY, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *Choose() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *>(VT_CHOOSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ANIMALZONEID, 4) &&
           VerifyOffset(verifier, VT_REFRESHTIME) &&
           verifier.VerifyString(RefreshTime()) &&
           VerifyField<int32_t>(verifier, VT_WEATHER, 4) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyOffset(verifier, VT_CHOOSE) &&
           verifier.VerifyVector(Choose()) &&
           verifier.VerifyVectorOfTables(Choose()) &&
           verifier.EndTable();
  }
  AnimalZoneSelectRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimalZoneSelectRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AnimalZoneSelectRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimalZoneSelectRowBuilder {
  typedef AnimalZoneSelectRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(AnimalZoneSelectRow::VT_ID, Id, 0);
  }
  void add_AnimalZoneId(uint32_t AnimalZoneId) {
    fbb_.AddElement<uint32_t>(AnimalZoneSelectRow::VT_ANIMALZONEID, AnimalZoneId, 0);
  }
  void add_RefreshTime(::flatbuffers::Offset<::flatbuffers::String> RefreshTime) {
    fbb_.AddOffset(AnimalZoneSelectRow::VT_REFRESHTIME, RefreshTime);
  }
  void add_Weather(fb::Weather Weather) {
    fbb_.AddElement<int32_t>(AnimalZoneSelectRow::VT_WEATHER, static_cast<int32_t>(Weather), 0);
  }
  void add_Priority(uint32_t Priority) {
    fbb_.AddElement<uint32_t>(AnimalZoneSelectRow::VT_PRIORITY, Priority, 0);
  }
  void add_Choose(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>> Choose) {
    fbb_.AddOffset(AnimalZoneSelectRow::VT_CHOOSE, Choose);
  }
  explicit AnimalZoneSelectRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimalZoneSelectRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimalZoneSelectRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimalZoneSelectRow> CreateAnimalZoneSelectRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    uint32_t AnimalZoneId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RefreshTime = 0,
    fb::Weather Weather = fb::Weather_NONE,
    uint32_t Priority = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>> Choose = 0) {
  AnimalZoneSelectRowBuilder builder_(_fbb);
  builder_.add_Choose(Choose);
  builder_.add_Priority(Priority);
  builder_.add_Weather(Weather);
  builder_.add_RefreshTime(RefreshTime);
  builder_.add_AnimalZoneId(AnimalZoneId);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimalZoneSelectRow> CreateAnimalZoneSelectRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    uint32_t AnimalZoneId = 0,
    const char *RefreshTime = nullptr,
    fb::Weather Weather = fb::Weather_NONE,
    uint32_t Priority = 0,
    const std::vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *Choose = nullptr) {
  auto RefreshTime__ = RefreshTime ? _fbb.CreateString(RefreshTime) : 0;
  auto Choose__ = Choose ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>(*Choose) : 0;
  return fb::CreateAnimalZoneSelectRow(
      _fbb,
      Id,
      AnimalZoneId,
      RefreshTime__,
      Weather,
      Priority,
      Choose__);
}

::flatbuffers::Offset<AnimalZoneSelectRow> CreateAnimalZoneSelectRow(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AnimalZoneSelectT::AnimalZoneSelectT(const AnimalZoneSelectT &o) {
  AnimalZoneSelects.reserve(o.AnimalZoneSelects.size());
  for (const auto &AnimalZoneSelects_ : o.AnimalZoneSelects) { AnimalZoneSelects.emplace_back((AnimalZoneSelects_) ? new fb::AnimalZoneSelectRowT(*AnimalZoneSelects_) : nullptr); }
}

inline AnimalZoneSelectT &AnimalZoneSelectT::operator=(AnimalZoneSelectT o) FLATBUFFERS_NOEXCEPT {
  std::swap(AnimalZoneSelects, o.AnimalZoneSelects);
  return *this;
}

inline AnimalZoneSelectT *AnimalZoneSelect::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimalZoneSelectT>(new AnimalZoneSelectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimalZoneSelect::UnPackTo(AnimalZoneSelectT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AnimalZoneSelects(); if (_e) { _o->AnimalZoneSelects.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->AnimalZoneSelects[_i]) { _e->Get(_i)->UnPackTo(_o->AnimalZoneSelects[_i].get(), _resolver); } else { _o->AnimalZoneSelects[_i] = std::unique_ptr<fb::AnimalZoneSelectRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->AnimalZoneSelects.resize(0); } }
}

inline ::flatbuffers::Offset<AnimalZoneSelect> AnimalZoneSelect::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimalZoneSelect(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AnimalZoneSelect> CreateAnimalZoneSelect(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AnimalZoneSelectT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AnimalZoneSelects = _o->AnimalZoneSelects.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::AnimalZoneSelectRow>> (_o->AnimalZoneSelects.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimalZoneSelectRow(*__va->__fbb, __va->__o->AnimalZoneSelects[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateAnimalZoneSelect(
      _fbb,
      _AnimalZoneSelects);
}

inline AnimalZoneSelectRowT::AnimalZoneSelectRowT(const AnimalZoneSelectRowT &o)
      : Id(o.Id),
        AnimalZoneId(o.AnimalZoneId),
        RefreshTime(o.RefreshTime),
        Weather(o.Weather),
        Priority(o.Priority) {
  Choose.reserve(o.Choose.size());
  for (const auto &Choose_ : o.Choose) { Choose.emplace_back((Choose_) ? new fb::tuple_uint32_uint32T(*Choose_) : nullptr); }
}

inline AnimalZoneSelectRowT &AnimalZoneSelectRowT::operator=(AnimalZoneSelectRowT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(AnimalZoneId, o.AnimalZoneId);
  std::swap(RefreshTime, o.RefreshTime);
  std::swap(Weather, o.Weather);
  std::swap(Priority, o.Priority);
  std::swap(Choose, o.Choose);
  return *this;
}

inline AnimalZoneSelectRowT *AnimalZoneSelectRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimalZoneSelectRowT>(new AnimalZoneSelectRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimalZoneSelectRow::UnPackTo(AnimalZoneSelectRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = AnimalZoneId(); _o->AnimalZoneId = _e; }
  { auto _e = RefreshTime(); if (_e) _o->RefreshTime = _e->str(); }
  { auto _e = Weather(); _o->Weather = _e; }
  { auto _e = Priority(); _o->Priority = _e; }
  { auto _e = Choose(); if (_e) { _o->Choose.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Choose[_i]) { _e->Get(_i)->UnPackTo(_o->Choose[_i].get(), _resolver); } else { _o->Choose[_i] = std::unique_ptr<fb::tuple_uint32_uint32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Choose.resize(0); } }
}

inline ::flatbuffers::Offset<AnimalZoneSelectRow> AnimalZoneSelectRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimalZoneSelectRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AnimalZoneSelectRow> CreateAnimalZoneSelectRow(::flatbuffers::FlatBufferBuilder &_fbb, const AnimalZoneSelectRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AnimalZoneSelectRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _AnimalZoneId = _o->AnimalZoneId;
  auto _RefreshTime = _o->RefreshTime.empty() ? 0 : _fbb.CreateString(_o->RefreshTime);
  auto _Weather = _o->Weather;
  auto _Priority = _o->Priority;
  auto _Choose = _o->Choose.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> (_o->Choose.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_uint32_uint32(*__va->__fbb, __va->__o->Choose[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateAnimalZoneSelectRow(
      _fbb,
      _Id,
      _AnimalZoneId,
      _RefreshTime,
      _Weather,
      _Priority,
      _Choose);
}

inline const fb::AnimalZoneSelect *GetAnimalZoneSelect(const void *buf) {
  return ::flatbuffers::GetRoot<fb::AnimalZoneSelect>(buf);
}

inline const fb::AnimalZoneSelect *GetSizePrefixedAnimalZoneSelect(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::AnimalZoneSelect>(buf);
}

inline bool VerifyAnimalZoneSelectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::AnimalZoneSelect>(nullptr);
}

inline bool VerifySizePrefixedAnimalZoneSelectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::AnimalZoneSelect>(nullptr);
}

inline void FinishAnimalZoneSelectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::AnimalZoneSelect> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAnimalZoneSelectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::AnimalZoneSelect> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::AnimalZoneSelectT> UnPackAnimalZoneSelect(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::AnimalZoneSelectT>(GetAnimalZoneSelect(buf)->UnPack(res));
}

inline std::unique_ptr<fb::AnimalZoneSelectT> UnPackSizePrefixedAnimalZoneSelect(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::AnimalZoneSelectT>(GetSizePrefixedAnimalZoneSelect(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ANIMALZONESELECT_FB_H_

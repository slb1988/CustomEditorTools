// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLDTYPE_FB_H_
#define FLATBUFFERS_GENERATED_WORLDTYPE_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct WorldType;
struct WorldTypeBuilder;
struct WorldTypeT;

struct WorldTypeRow;
struct WorldTypeRowBuilder;
struct WorldTypeRowT;

struct WorldTypeT : public ::flatbuffers::NativeTable {
  typedef WorldType TableType;
  std::vector<std::unique_ptr<fb::WorldTypeRowT>> WorldTypes{};
  WorldTypeT() = default;
  WorldTypeT(const WorldTypeT &o);
  WorldTypeT(WorldTypeT&&) FLATBUFFERS_NOEXCEPT = default;
  WorldTypeT &operator=(WorldTypeT o) FLATBUFFERS_NOEXCEPT;
};

struct WorldType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WorldTypeT NativeTableType;
  typedef WorldTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORLDTYPES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::WorldTypeRow>> *WorldTypes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::WorldTypeRow>> *>(VT_WORLDTYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WORLDTYPES) &&
           verifier.VerifyVector(WorldTypes()) &&
           verifier.VerifyVectorOfTables(WorldTypes()) &&
           verifier.EndTable();
  }
  WorldTypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WorldTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WorldType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WorldTypeBuilder {
  typedef WorldType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_WorldTypes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::WorldTypeRow>>> WorldTypes) {
    fbb_.AddOffset(WorldType::VT_WORLDTYPES, WorldTypes);
  }
  explicit WorldTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WorldType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WorldType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WorldType> CreateWorldType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::WorldTypeRow>>> WorldTypes = 0) {
  WorldTypeBuilder builder_(_fbb);
  builder_.add_WorldTypes(WorldTypes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WorldType> CreateWorldTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::WorldTypeRow>> *WorldTypes = nullptr) {
  auto WorldTypes__ = WorldTypes ? _fbb.CreateVector<::flatbuffers::Offset<fb::WorldTypeRow>>(*WorldTypes) : 0;
  return fb::CreateWorldType(
      _fbb,
      WorldTypes__);
}

::flatbuffers::Offset<WorldType> CreateWorldType(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WorldTypeRowT : public ::flatbuffers::NativeTable {
  typedef WorldTypeRow TableType;
  uint32_t Id = 0;
  std::vector<std::unique_ptr<fb::tuple_float32_float32_float32_float32T>> BornPoint{};
  uint32_t StartTime = 0;
  std::unique_ptr<fb::tuple_uint32_uint32T> TimeConvert{};
  std::string ClientSceneName{};
  bool ChallengeTimerOn = false;
  WorldTypeRowT() = default;
  WorldTypeRowT(const WorldTypeRowT &o);
  WorldTypeRowT(WorldTypeRowT&&) FLATBUFFERS_NOEXCEPT = default;
  WorldTypeRowT &operator=(WorldTypeRowT o) FLATBUFFERS_NOEXCEPT;
};

struct WorldTypeRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WorldTypeRowT NativeTableType;
  typedef WorldTypeRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_BORNPOINT = 6,
    VT_STARTTIME = 8,
    VT_TIMECONVERT = 10,
    VT_CLIENTSCENENAME = 12,
    VT_CHALLENGETIMERON = 14
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>> *BornPoint() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>> *>(VT_BORNPOINT);
  }
  uint32_t StartTime() const {
    return GetField<uint32_t>(VT_STARTTIME, 0);
  }
  const fb::tuple_uint32_uint32 *TimeConvert() const {
    return GetPointer<const fb::tuple_uint32_uint32 *>(VT_TIMECONVERT);
  }
  const ::flatbuffers::String *ClientSceneName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLIENTSCENENAME);
  }
  bool ChallengeTimerOn() const {
    return GetField<uint8_t>(VT_CHALLENGETIMERON, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_BORNPOINT) &&
           verifier.VerifyVector(BornPoint()) &&
           verifier.VerifyVectorOfTables(BornPoint()) &&
           VerifyField<uint32_t>(verifier, VT_STARTTIME, 4) &&
           VerifyOffset(verifier, VT_TIMECONVERT) &&
           verifier.VerifyTable(TimeConvert()) &&
           VerifyOffset(verifier, VT_CLIENTSCENENAME) &&
           verifier.VerifyString(ClientSceneName()) &&
           VerifyField<uint8_t>(verifier, VT_CHALLENGETIMERON, 1) &&
           verifier.EndTable();
  }
  WorldTypeRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WorldTypeRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WorldTypeRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WorldTypeRowBuilder {
  typedef WorldTypeRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(WorldTypeRow::VT_ID, Id, 0);
  }
  void add_BornPoint(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>>> BornPoint) {
    fbb_.AddOffset(WorldTypeRow::VT_BORNPOINT, BornPoint);
  }
  void add_StartTime(uint32_t StartTime) {
    fbb_.AddElement<uint32_t>(WorldTypeRow::VT_STARTTIME, StartTime, 0);
  }
  void add_TimeConvert(::flatbuffers::Offset<fb::tuple_uint32_uint32> TimeConvert) {
    fbb_.AddOffset(WorldTypeRow::VT_TIMECONVERT, TimeConvert);
  }
  void add_ClientSceneName(::flatbuffers::Offset<::flatbuffers::String> ClientSceneName) {
    fbb_.AddOffset(WorldTypeRow::VT_CLIENTSCENENAME, ClientSceneName);
  }
  void add_ChallengeTimerOn(bool ChallengeTimerOn) {
    fbb_.AddElement<uint8_t>(WorldTypeRow::VT_CHALLENGETIMERON, static_cast<uint8_t>(ChallengeTimerOn), 0);
  }
  explicit WorldTypeRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WorldTypeRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WorldTypeRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WorldTypeRow> CreateWorldTypeRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>>> BornPoint = 0,
    uint32_t StartTime = 0,
    ::flatbuffers::Offset<fb::tuple_uint32_uint32> TimeConvert = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ClientSceneName = 0,
    bool ChallengeTimerOn = false) {
  WorldTypeRowBuilder builder_(_fbb);
  builder_.add_ClientSceneName(ClientSceneName);
  builder_.add_TimeConvert(TimeConvert);
  builder_.add_StartTime(StartTime);
  builder_.add_BornPoint(BornPoint);
  builder_.add_Id(Id);
  builder_.add_ChallengeTimerOn(ChallengeTimerOn);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WorldTypeRow> CreateWorldTypeRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    const std::vector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>> *BornPoint = nullptr,
    uint32_t StartTime = 0,
    ::flatbuffers::Offset<fb::tuple_uint32_uint32> TimeConvert = 0,
    const char *ClientSceneName = nullptr,
    bool ChallengeTimerOn = false) {
  auto BornPoint__ = BornPoint ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>>(*BornPoint) : 0;
  auto ClientSceneName__ = ClientSceneName ? _fbb.CreateString(ClientSceneName) : 0;
  return fb::CreateWorldTypeRow(
      _fbb,
      Id,
      BornPoint__,
      StartTime,
      TimeConvert,
      ClientSceneName__,
      ChallengeTimerOn);
}

::flatbuffers::Offset<WorldTypeRow> CreateWorldTypeRow(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline WorldTypeT::WorldTypeT(const WorldTypeT &o) {
  WorldTypes.reserve(o.WorldTypes.size());
  for (const auto &WorldTypes_ : o.WorldTypes) { WorldTypes.emplace_back((WorldTypes_) ? new fb::WorldTypeRowT(*WorldTypes_) : nullptr); }
}

inline WorldTypeT &WorldTypeT::operator=(WorldTypeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(WorldTypes, o.WorldTypes);
  return *this;
}

inline WorldTypeT *WorldType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WorldTypeT>(new WorldTypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WorldType::UnPackTo(WorldTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = WorldTypes(); if (_e) { _o->WorldTypes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->WorldTypes[_i]) { _e->Get(_i)->UnPackTo(_o->WorldTypes[_i].get(), _resolver); } else { _o->WorldTypes[_i] = std::unique_ptr<fb::WorldTypeRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->WorldTypes.resize(0); } }
}

inline ::flatbuffers::Offset<WorldType> WorldType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWorldType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WorldType> CreateWorldType(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WorldTypeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _WorldTypes = _o->WorldTypes.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::WorldTypeRow>> (_o->WorldTypes.size(), [](size_t i, _VectorArgs *__va) { return CreateWorldTypeRow(*__va->__fbb, __va->__o->WorldTypes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateWorldType(
      _fbb,
      _WorldTypes);
}

inline WorldTypeRowT::WorldTypeRowT(const WorldTypeRowT &o)
      : Id(o.Id),
        StartTime(o.StartTime),
        TimeConvert((o.TimeConvert) ? new fb::tuple_uint32_uint32T(*o.TimeConvert) : nullptr),
        ClientSceneName(o.ClientSceneName),
        ChallengeTimerOn(o.ChallengeTimerOn) {
  BornPoint.reserve(o.BornPoint.size());
  for (const auto &BornPoint_ : o.BornPoint) { BornPoint.emplace_back((BornPoint_) ? new fb::tuple_float32_float32_float32_float32T(*BornPoint_) : nullptr); }
}

inline WorldTypeRowT &WorldTypeRowT::operator=(WorldTypeRowT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(BornPoint, o.BornPoint);
  std::swap(StartTime, o.StartTime);
  std::swap(TimeConvert, o.TimeConvert);
  std::swap(ClientSceneName, o.ClientSceneName);
  std::swap(ChallengeTimerOn, o.ChallengeTimerOn);
  return *this;
}

inline WorldTypeRowT *WorldTypeRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WorldTypeRowT>(new WorldTypeRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WorldTypeRow::UnPackTo(WorldTypeRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = BornPoint(); if (_e) { _o->BornPoint.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->BornPoint[_i]) { _e->Get(_i)->UnPackTo(_o->BornPoint[_i].get(), _resolver); } else { _o->BornPoint[_i] = std::unique_ptr<fb::tuple_float32_float32_float32_float32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->BornPoint.resize(0); } }
  { auto _e = StartTime(); _o->StartTime = _e; }
  { auto _e = TimeConvert(); if (_e) { if(_o->TimeConvert) { _e->UnPackTo(_o->TimeConvert.get(), _resolver); } else { _o->TimeConvert = std::unique_ptr<fb::tuple_uint32_uint32T>(_e->UnPack(_resolver)); } } else if (_o->TimeConvert) { _o->TimeConvert.reset(); } }
  { auto _e = ClientSceneName(); if (_e) _o->ClientSceneName = _e->str(); }
  { auto _e = ChallengeTimerOn(); _o->ChallengeTimerOn = _e; }
}

inline ::flatbuffers::Offset<WorldTypeRow> WorldTypeRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWorldTypeRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WorldTypeRow> CreateWorldTypeRow(::flatbuffers::FlatBufferBuilder &_fbb, const WorldTypeRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WorldTypeRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _BornPoint = _o->BornPoint.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_float32_float32_float32_float32>> (_o->BornPoint.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_float32_float32_float32_float32(*__va->__fbb, __va->__o->BornPoint[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _StartTime = _o->StartTime;
  auto _TimeConvert = _o->TimeConvert ? Createtuple_uint32_uint32(_fbb, _o->TimeConvert.get(), _rehasher) : 0;
  auto _ClientSceneName = _o->ClientSceneName.empty() ? 0 : _fbb.CreateString(_o->ClientSceneName);
  auto _ChallengeTimerOn = _o->ChallengeTimerOn;
  return fb::CreateWorldTypeRow(
      _fbb,
      _Id,
      _BornPoint,
      _StartTime,
      _TimeConvert,
      _ClientSceneName,
      _ChallengeTimerOn);
}

inline const fb::WorldType *GetWorldType(const void *buf) {
  return ::flatbuffers::GetRoot<fb::WorldType>(buf);
}

inline const fb::WorldType *GetSizePrefixedWorldType(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::WorldType>(buf);
}

inline bool VerifyWorldTypeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::WorldType>(nullptr);
}

inline bool VerifySizePrefixedWorldTypeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::WorldType>(nullptr);
}

inline void FinishWorldTypeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::WorldType> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWorldTypeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::WorldType> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::WorldTypeT> UnPackWorldType(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::WorldTypeT>(GetWorldType(buf)->UnPack(res));
}

inline std::unique_ptr<fb::WorldTypeT> UnPackSizePrefixedWorldType(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::WorldTypeT>(GetSizePrefixedWorldType(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_WORLDTYPE_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENUMS_FB_H_
#define FLATBUFFERS_GENERATED_ENUMS_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

enum ActionType : int32_t {
  ActionType_NONE = 0,
  ActionType_ADD_X_INSTRMENT_Y_EXP = 1,
  ActionType_START_X_TIMER = 2,
  ActionType_CREATE_X_SCENE_NPC = 3,
  ActionType_DESTROY_X_SCENE_NPC = 4,
  ActionType_MOVE_X_SCENE_NPC = 5,
  ActionType_PRINT_DEBUG_LOG = 999,
  ActionType_MIN = ActionType_NONE,
  ActionType_MAX = ActionType_PRINT_DEBUG_LOG
};

inline const ActionType (&EnumValuesActionType())[7] {
  static const ActionType values[] = {
    ActionType_NONE,
    ActionType_ADD_X_INSTRMENT_Y_EXP,
    ActionType_START_X_TIMER,
    ActionType_CREATE_X_SCENE_NPC,
    ActionType_DESTROY_X_SCENE_NPC,
    ActionType_MOVE_X_SCENE_NPC,
    ActionType_PRINT_DEBUG_LOG
  };
  return values;
}

inline const char *EnumNameActionType(ActionType e) {
  switch (e) {
    case ActionType_NONE: return "NONE";
    case ActionType_ADD_X_INSTRMENT_Y_EXP: return "ADD_X_INSTRMENT_Y_EXP";
    case ActionType_START_X_TIMER: return "START_X_TIMER";
    case ActionType_CREATE_X_SCENE_NPC: return "CREATE_X_SCENE_NPC";
    case ActionType_DESTROY_X_SCENE_NPC: return "DESTROY_X_SCENE_NPC";
    case ActionType_MOVE_X_SCENE_NPC: return "MOVE_X_SCENE_NPC";
    case ActionType_PRINT_DEBUG_LOG: return "PRINT_DEBUG_LOG";
    default: return "";
  }
}

enum AnimalType : int32_t {
  AnimalType_NONE = 0,
  AnimalType_FISH = 1,
  AnimalType_ANIMAL = 2,
  AnimalType_MIN = AnimalType_NONE,
  AnimalType_MAX = AnimalType_ANIMAL
};

inline const AnimalType (&EnumValuesAnimalType())[3] {
  static const AnimalType values[] = {
    AnimalType_NONE,
    AnimalType_FISH,
    AnimalType_ANIMAL
  };
  return values;
}

inline const char * const *EnumNamesAnimalType() {
  static const char * const names[4] = {
    "NONE",
    "FISH",
    "ANIMAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnimalType(AnimalType e) {
  if (::flatbuffers::IsOutRange(e, AnimalType_NONE, AnimalType_ANIMAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnimalType()[index];
}

enum AttributeType : int32_t {
  AttributeType_NONE = 0,
  AttributeType_AUTO_RECOVER_RATE = 1,
  AttributeType_ASSIST_RECOVER_RATE = 2,
  AttributeType_ABSORB_RANGE_UP = 3,
  AttributeType_CRYSTAL_INDUCT_RANGE_UP = 4,
  AttributeType_SPURT_SPEED_UP = 5,
  AttributeType_SPURT_TIME_UP = 6,
  AttributeType_SPURT_COST_DOWN_PERCENT = 7,
  AttributeType_BRAKE_DIS_DOWN = 8,
  AttributeType_HOVER_COST_DOWN_PERCENT = 9,
  AttributeType_MIN = AttributeType_NONE,
  AttributeType_MAX = AttributeType_HOVER_COST_DOWN_PERCENT
};

inline const AttributeType (&EnumValuesAttributeType())[10] {
  static const AttributeType values[] = {
    AttributeType_NONE,
    AttributeType_AUTO_RECOVER_RATE,
    AttributeType_ASSIST_RECOVER_RATE,
    AttributeType_ABSORB_RANGE_UP,
    AttributeType_CRYSTAL_INDUCT_RANGE_UP,
    AttributeType_SPURT_SPEED_UP,
    AttributeType_SPURT_TIME_UP,
    AttributeType_SPURT_COST_DOWN_PERCENT,
    AttributeType_BRAKE_DIS_DOWN,
    AttributeType_HOVER_COST_DOWN_PERCENT
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[11] = {
    "NONE",
    "AUTO_RECOVER_RATE",
    "ASSIST_RECOVER_RATE",
    "ABSORB_RANGE_UP",
    "CRYSTAL_INDUCT_RANGE_UP",
    "SPURT_SPEED_UP",
    "SPURT_TIME_UP",
    "SPURT_COST_DOWN_PERCENT",
    "BRAKE_DIS_DOWN",
    "HOVER_COST_DOWN_PERCENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (::flatbuffers::IsOutRange(e, AttributeType_NONE, AttributeType_HOVER_COST_DOWN_PERCENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum AvatarSkeletonType : int32_t {
  AvatarSkeletonType_GENERAL = 0,
  AvatarSkeletonType_BOY = 1,
  AvatarSkeletonType_GIRL = 2,
  AvatarSkeletonType_LOLI = 3,
  AvatarSkeletonType_MIN = AvatarSkeletonType_GENERAL,
  AvatarSkeletonType_MAX = AvatarSkeletonType_LOLI
};

inline const AvatarSkeletonType (&EnumValuesAvatarSkeletonType())[4] {
  static const AvatarSkeletonType values[] = {
    AvatarSkeletonType_GENERAL,
    AvatarSkeletonType_BOY,
    AvatarSkeletonType_GIRL,
    AvatarSkeletonType_LOLI
  };
  return values;
}

inline const char * const *EnumNamesAvatarSkeletonType() {
  static const char * const names[5] = {
    "GENERAL",
    "BOY",
    "GIRL",
    "LOLI",
    nullptr
  };
  return names;
}

inline const char *EnumNameAvatarSkeletonType(AvatarSkeletonType e) {
  if (::flatbuffers::IsOutRange(e, AvatarSkeletonType_GENERAL, AvatarSkeletonType_LOLI)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAvatarSkeletonType()[index];
}

enum BuffType : int32_t {
  BuffType_NONE = 0,
  BuffType_ALL = 1,
  BuffType_INVINCIBLE = 2,
  BuffType_ENERGY_RECOVER_SUSTAINED = 101,
  BuffType_ENERGY_REDUCE_SUSTAINED = 201,
  BuffType_LIGHTING_SHIELD = 301,
  BuffType_SPEED_CHANGE_TO_TARGET = 401,
  BuffType_SPEED_CHANGE = 402,
  BuffType_ENERGY_CHANGE_ONCE = 501,
  BuffType_PLAYER_STATE_CHANGE = 601,
  BuffType_MIN = BuffType_NONE,
  BuffType_MAX = BuffType_PLAYER_STATE_CHANGE
};

inline const BuffType (&EnumValuesBuffType())[10] {
  static const BuffType values[] = {
    BuffType_NONE,
    BuffType_ALL,
    BuffType_INVINCIBLE,
    BuffType_ENERGY_RECOVER_SUSTAINED,
    BuffType_ENERGY_REDUCE_SUSTAINED,
    BuffType_LIGHTING_SHIELD,
    BuffType_SPEED_CHANGE_TO_TARGET,
    BuffType_SPEED_CHANGE,
    BuffType_ENERGY_CHANGE_ONCE,
    BuffType_PLAYER_STATE_CHANGE
  };
  return values;
}

inline const char *EnumNameBuffType(BuffType e) {
  switch (e) {
    case BuffType_NONE: return "NONE";
    case BuffType_ALL: return "ALL";
    case BuffType_INVINCIBLE: return "INVINCIBLE";
    case BuffType_ENERGY_RECOVER_SUSTAINED: return "ENERGY_RECOVER_SUSTAINED";
    case BuffType_ENERGY_REDUCE_SUSTAINED: return "ENERGY_REDUCE_SUSTAINED";
    case BuffType_LIGHTING_SHIELD: return "LIGHTING_SHIELD";
    case BuffType_SPEED_CHANGE_TO_TARGET: return "SPEED_CHANGE_TO_TARGET";
    case BuffType_SPEED_CHANGE: return "SPEED_CHANGE";
    case BuffType_ENERGY_CHANGE_ONCE: return "ENERGY_CHANGE_ONCE";
    case BuffType_PLAYER_STATE_CHANGE: return "PLAYER_STATE_CHANGE";
    default: return "";
  }
}

enum CollectRefreshType : int32_t {
  CollectRefreshType_NONE = 0,
  CollectRefreshType_TIME = 1,
  CollectRefreshType_WEATHER = 2,
  CollectRefreshType_EVENT = 3,
  CollectRefreshType_MIN = CollectRefreshType_NONE,
  CollectRefreshType_MAX = CollectRefreshType_EVENT
};

inline const CollectRefreshType (&EnumValuesCollectRefreshType())[4] {
  static const CollectRefreshType values[] = {
    CollectRefreshType_NONE,
    CollectRefreshType_TIME,
    CollectRefreshType_WEATHER,
    CollectRefreshType_EVENT
  };
  return values;
}

inline const char * const *EnumNamesCollectRefreshType() {
  static const char * const names[5] = {
    "NONE",
    "TIME",
    "WEATHER",
    "EVENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameCollectRefreshType(CollectRefreshType e) {
  if (::flatbuffers::IsOutRange(e, CollectRefreshType_NONE, CollectRefreshType_EVENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCollectRefreshType()[index];
}

enum ConditionGroupType : int32_t {
  ConditionGroupType_NONE = 0,
  ConditionGroupType_ALL = 1,
  ConditionGroupType_ANY = 2,
  ConditionGroupType_MOST = 3,
  ConditionGroupType_MIN = ConditionGroupType_NONE,
  ConditionGroupType_MAX = ConditionGroupType_MOST
};

inline const ConditionGroupType (&EnumValuesConditionGroupType())[4] {
  static const ConditionGroupType values[] = {
    ConditionGroupType_NONE,
    ConditionGroupType_ALL,
    ConditionGroupType_ANY,
    ConditionGroupType_MOST
  };
  return values;
}

inline const char * const *EnumNamesConditionGroupType() {
  static const char * const names[5] = {
    "NONE",
    "ALL",
    "ANY",
    "MOST",
    nullptr
  };
  return names;
}

inline const char *EnumNameConditionGroupType(ConditionGroupType e) {
  if (::flatbuffers::IsOutRange(e, ConditionGroupType_NONE, ConditionGroupType_MOST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConditionGroupType()[index];
}

enum ConditionType : int32_t {
  ConditionType_NONE = 0,
  ConditionType_OBTAIN_X_ITEM = 1,
  ConditionType_CONSUME_X_ITEM = 2,
  ConditionType_TEAM_MEMBER_X_COUNT = 3,
  ConditionType_USE_X_INSTRUMENT = 4,
  ConditionType_ARRIVE_X_TASK_REGION = 5,
  ConditionType_UNLOCK_X_TASK = 6,
  ConditionType_ACCEPT_X_TASK = 7,
  ConditionType_FINISH_X_TASK = 8,
  ConditionType_X_TASK_REACH_Y_STAGE = 9,
  ConditionType_PLAYER_X_ATTR_Y_VALUE = 10,
  ConditionType_START_TALK_WITH_X_NPC = 11,
  ConditionType_FINISH_TALK_WITH_X_NPC = 12,
  ConditionType_COLLECT_X_NPC = 13,
  ConditionType_COLLECT_X_TYPE_NPC = 14,
  ConditionType_PICK_UP_X_ITEM = 15,
  ConditionType_MIN = ConditionType_NONE,
  ConditionType_MAX = ConditionType_PICK_UP_X_ITEM
};

inline const ConditionType (&EnumValuesConditionType())[16] {
  static const ConditionType values[] = {
    ConditionType_NONE,
    ConditionType_OBTAIN_X_ITEM,
    ConditionType_CONSUME_X_ITEM,
    ConditionType_TEAM_MEMBER_X_COUNT,
    ConditionType_USE_X_INSTRUMENT,
    ConditionType_ARRIVE_X_TASK_REGION,
    ConditionType_UNLOCK_X_TASK,
    ConditionType_ACCEPT_X_TASK,
    ConditionType_FINISH_X_TASK,
    ConditionType_X_TASK_REACH_Y_STAGE,
    ConditionType_PLAYER_X_ATTR_Y_VALUE,
    ConditionType_START_TALK_WITH_X_NPC,
    ConditionType_FINISH_TALK_WITH_X_NPC,
    ConditionType_COLLECT_X_NPC,
    ConditionType_COLLECT_X_TYPE_NPC,
    ConditionType_PICK_UP_X_ITEM
  };
  return values;
}

inline const char * const *EnumNamesConditionType() {
  static const char * const names[17] = {
    "NONE",
    "OBTAIN_X_ITEM",
    "CONSUME_X_ITEM",
    "TEAM_MEMBER_X_COUNT",
    "USE_X_INSTRUMENT",
    "ARRIVE_X_TASK_REGION",
    "UNLOCK_X_TASK",
    "ACCEPT_X_TASK",
    "FINISH_X_TASK",
    "X_TASK_REACH_Y_STAGE",
    "PLAYER_X_ATTR_Y_VALUE",
    "START_TALK_WITH_X_NPC",
    "FINISH_TALK_WITH_X_NPC",
    "COLLECT_X_NPC",
    "COLLECT_X_TYPE_NPC",
    "PICK_UP_X_ITEM",
    nullptr
  };
  return names;
}

inline const char *EnumNameConditionType(ConditionType e) {
  if (::flatbuffers::IsOutRange(e, ConditionType_NONE, ConditionType_PICK_UP_X_ITEM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConditionType()[index];
}

enum DevelopUnlockType : int32_t {
  DevelopUnlockType_NONE = 0,
  DevelopUnlockType_ATTRIBUTE = 1,
  DevelopUnlockType_ACTION = 2,
  DevelopUnlockType_SPECIAL_EFFECT = 3,
  DevelopUnlockType_ENERGY_LIMIT = 4,
  DevelopUnlockType_APPEARANCE = 5,
  DevelopUnlockType_MIN = DevelopUnlockType_NONE,
  DevelopUnlockType_MAX = DevelopUnlockType_APPEARANCE
};

inline const DevelopUnlockType (&EnumValuesDevelopUnlockType())[6] {
  static const DevelopUnlockType values[] = {
    DevelopUnlockType_NONE,
    DevelopUnlockType_ATTRIBUTE,
    DevelopUnlockType_ACTION,
    DevelopUnlockType_SPECIAL_EFFECT,
    DevelopUnlockType_ENERGY_LIMIT,
    DevelopUnlockType_APPEARANCE
  };
  return values;
}

inline const char * const *EnumNamesDevelopUnlockType() {
  static const char * const names[7] = {
    "NONE",
    "ATTRIBUTE",
    "ACTION",
    "SPECIAL_EFFECT",
    "ENERGY_LIMIT",
    "APPEARANCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDevelopUnlockType(DevelopUnlockType e) {
  if (::flatbuffers::IsOutRange(e, DevelopUnlockType_NONE, DevelopUnlockType_APPEARANCE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDevelopUnlockType()[index];
}

enum ItemType : int32_t {
  ItemType_NONE = 0,
  ItemType_FAN = 1,
  ItemType_FISHING_ROD = 2,
  ItemType_STAR = 3,
  ItemType_MOTE = 4,
  ItemType_FISH = 50,
  ItemType_FOOD = 61,
  ItemType_MIN = ItemType_NONE,
  ItemType_MAX = ItemType_FOOD
};

inline const ItemType (&EnumValuesItemType())[7] {
  static const ItemType values[] = {
    ItemType_NONE,
    ItemType_FAN,
    ItemType_FISHING_ROD,
    ItemType_STAR,
    ItemType_MOTE,
    ItemType_FISH,
    ItemType_FOOD
  };
  return values;
}

inline const char *EnumNameItemType(ItemType e) {
  switch (e) {
    case ItemType_NONE: return "NONE";
    case ItemType_FAN: return "FAN";
    case ItemType_FISHING_ROD: return "FISHING_ROD";
    case ItemType_STAR: return "STAR";
    case ItemType_MOTE: return "MOTE";
    case ItemType_FISH: return "FISH";
    case ItemType_FOOD: return "FOOD";
    default: return "";
  }
}

enum TestEnum : int32_t {
  TestEnum_NONE = 0,
  TestEnum_TEST_ENUM_1 = 1,
  TestEnum_TEST_ENUM_2 = 2,
  TestEnum_TEST_ENUM_3 = 3,
  TestEnum_TEST_ENUM_4 = 4,
  TestEnum_TEST_ENUM_5 = 5,
  TestEnum_MIN = TestEnum_NONE,
  TestEnum_MAX = TestEnum_TEST_ENUM_5
};

inline const TestEnum (&EnumValuesTestEnum())[6] {
  static const TestEnum values[] = {
    TestEnum_NONE,
    TestEnum_TEST_ENUM_1,
    TestEnum_TEST_ENUM_2,
    TestEnum_TEST_ENUM_3,
    TestEnum_TEST_ENUM_4,
    TestEnum_TEST_ENUM_5
  };
  return values;
}

inline const char * const *EnumNamesTestEnum() {
  static const char * const names[7] = {
    "NONE",
    "TEST_ENUM_1",
    "TEST_ENUM_2",
    "TEST_ENUM_3",
    "TEST_ENUM_4",
    "TEST_ENUM_5",
    nullptr
  };
  return names;
}

inline const char *EnumNameTestEnum(TestEnum e) {
  if (::flatbuffers::IsOutRange(e, TestEnum_NONE, TestEnum_TEST_ENUM_5)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTestEnum()[index];
}

enum InteractionDisplayType : int32_t {
  InteractionDisplayType_NONE = 0,
  InteractionDisplayType_COEXIST = 1,
  InteractionDisplayType_INDEPENDENT = 2,
  InteractionDisplayType_MIN = InteractionDisplayType_NONE,
  InteractionDisplayType_MAX = InteractionDisplayType_INDEPENDENT
};

inline const InteractionDisplayType (&EnumValuesInteractionDisplayType())[3] {
  static const InteractionDisplayType values[] = {
    InteractionDisplayType_NONE,
    InteractionDisplayType_COEXIST,
    InteractionDisplayType_INDEPENDENT
  };
  return values;
}

inline const char * const *EnumNamesInteractionDisplayType() {
  static const char * const names[4] = {
    "NONE",
    "COEXIST",
    "INDEPENDENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameInteractionDisplayType(InteractionDisplayType e) {
  if (::flatbuffers::IsOutRange(e, InteractionDisplayType_NONE, InteractionDisplayType_INDEPENDENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInteractionDisplayType()[index];
}

enum InteractIonType : int32_t {
  InteractIonType_NONE = 0,
  InteractIonType_COLLECT = 1,
  InteractIonType_TALK = 2,
  InteractIonType_CHAT = 3,
  InteractIonType_ACTIVATE = 4,
  InteractIonType_TREE = 5,
  InteractIonType_MIN = InteractIonType_NONE,
  InteractIonType_MAX = InteractIonType_TREE
};

inline const InteractIonType (&EnumValuesInteractIonType())[6] {
  static const InteractIonType values[] = {
    InteractIonType_NONE,
    InteractIonType_COLLECT,
    InteractIonType_TALK,
    InteractIonType_CHAT,
    InteractIonType_ACTIVATE,
    InteractIonType_TREE
  };
  return values;
}

inline const char * const *EnumNamesInteractIonType() {
  static const char * const names[7] = {
    "NONE",
    "COLLECT",
    "TALK",
    "CHAT",
    "ACTIVATE",
    "TREE",
    nullptr
  };
  return names;
}

inline const char *EnumNameInteractIonType(InteractIonType e) {
  if (::flatbuffers::IsOutRange(e, InteractIonType_NONE, InteractIonType_TREE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInteractIonType()[index];
}

enum MusicalNoteType : int32_t {
  MusicalNoteType_NONE = 0,
  MusicalNoteType_A = 1,
  MusicalNoteType_B = 2,
  MusicalNoteType_C = 3,
  MusicalNoteType_D = 4,
  MusicalNoteType_MIN = MusicalNoteType_NONE,
  MusicalNoteType_MAX = MusicalNoteType_D
};

inline const MusicalNoteType (&EnumValuesMusicalNoteType())[5] {
  static const MusicalNoteType values[] = {
    MusicalNoteType_NONE,
    MusicalNoteType_A,
    MusicalNoteType_B,
    MusicalNoteType_C,
    MusicalNoteType_D
  };
  return values;
}

inline const char * const *EnumNamesMusicalNoteType() {
  static const char * const names[6] = {
    "NONE",
    "A",
    "B",
    "C",
    "D",
    nullptr
  };
  return names;
}

inline const char *EnumNameMusicalNoteType(MusicalNoteType e) {
  if (::flatbuffers::IsOutRange(e, MusicalNoteType_NONE, MusicalNoteType_D)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMusicalNoteType()[index];
}

enum MusicType : int32_t {
  MusicType_NONE = 0,
  MusicType_HAPPY = 1,
  MusicType_PEACE = 2,
  MusicType_CHEERFUL = 3,
  MusicType_BRAVE = 4,
  MusicType_MIN = MusicType_NONE,
  MusicType_MAX = MusicType_BRAVE
};

inline const MusicType (&EnumValuesMusicType())[5] {
  static const MusicType values[] = {
    MusicType_NONE,
    MusicType_HAPPY,
    MusicType_PEACE,
    MusicType_CHEERFUL,
    MusicType_BRAVE
  };
  return values;
}

inline const char * const *EnumNamesMusicType() {
  static const char * const names[6] = {
    "NONE",
    "HAPPY",
    "PEACE",
    "CHEERFUL",
    "BRAVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMusicType(MusicType e) {
  if (::flatbuffers::IsOutRange(e, MusicType_NONE, MusicType_BRAVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMusicType()[index];
}

enum NpcMoveType : int32_t {
  NpcMoveType_NONE = 0,
  NpcMoveType_LOOP = 1,
  NpcMoveType_BACK_AND_FORTH = 2,
  NpcMoveType_RANDOM = 3,
  NpcMoveType_MIN = NpcMoveType_NONE,
  NpcMoveType_MAX = NpcMoveType_RANDOM
};

inline const NpcMoveType (&EnumValuesNpcMoveType())[4] {
  static const NpcMoveType values[] = {
    NpcMoveType_NONE,
    NpcMoveType_LOOP,
    NpcMoveType_BACK_AND_FORTH,
    NpcMoveType_RANDOM
  };
  return values;
}

inline const char * const *EnumNamesNpcMoveType() {
  static const char * const names[5] = {
    "NONE",
    "LOOP",
    "BACK_AND_FORTH",
    "RANDOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameNpcMoveType(NpcMoveType e) {
  if (::flatbuffers::IsOutRange(e, NpcMoveType_NONE, NpcMoveType_RANDOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNpcMoveType()[index];
}

enum PlaceableTag : int32_t {
  PlaceableTag_NONE = 0,
  PlaceableTag_StaticBlock = 1,
  PlaceableTag_DynamicBlock = 2,
  PlaceableTag_Hazard = 4,
  PlaceableTag_ProjectileLauncher = 8,
  PlaceableTag_Bomb = 16,
  PlaceableTag_Coin = 32,
  PlaceableTag_Glue = 64,
  PlaceableTag_Attachment = 128,
  PlaceableTag_SetPiece = 256,
  PlaceableTag_MovingPlatform = 512,
  PlaceableTag_MIN = PlaceableTag_NONE,
  PlaceableTag_MAX = PlaceableTag_MovingPlatform
};

inline const PlaceableTag (&EnumValuesPlaceableTag())[11] {
  static const PlaceableTag values[] = {
    PlaceableTag_NONE,
    PlaceableTag_StaticBlock,
    PlaceableTag_DynamicBlock,
    PlaceableTag_Hazard,
    PlaceableTag_ProjectileLauncher,
    PlaceableTag_Bomb,
    PlaceableTag_Coin,
    PlaceableTag_Glue,
    PlaceableTag_Attachment,
    PlaceableTag_SetPiece,
    PlaceableTag_MovingPlatform
  };
  return values;
}

inline const char *EnumNamePlaceableTag(PlaceableTag e) {
  switch (e) {
    case PlaceableTag_NONE: return "NONE";
    case PlaceableTag_StaticBlock: return "StaticBlock";
    case PlaceableTag_DynamicBlock: return "DynamicBlock";
    case PlaceableTag_Hazard: return "Hazard";
    case PlaceableTag_ProjectileLauncher: return "ProjectileLauncher";
    case PlaceableTag_Bomb: return "Bomb";
    case PlaceableTag_Coin: return "Coin";
    case PlaceableTag_Glue: return "Glue";
    case PlaceableTag_Attachment: return "Attachment";
    case PlaceableTag_SetPiece: return "SetPiece";
    case PlaceableTag_MovingPlatform: return "MovingPlatform";
    default: return "";
  }
}

enum Quality : int32_t {
  Quality_NONE = 0,
  Quality_POOR = 1,
  Quality_COMMON = 2,
  Quality_UNCOMMON = 3,
  Quality_RARE = 4,
  Quality_EPIC = 5,
  Quality_LEGENDARY = 6,
  Quality_MIN = Quality_NONE,
  Quality_MAX = Quality_LEGENDARY
};

inline const Quality (&EnumValuesQuality())[7] {
  static const Quality values[] = {
    Quality_NONE,
    Quality_POOR,
    Quality_COMMON,
    Quality_UNCOMMON,
    Quality_RARE,
    Quality_EPIC,
    Quality_LEGENDARY
  };
  return values;
}

inline const char * const *EnumNamesQuality() {
  static const char * const names[8] = {
    "NONE",
    "POOR",
    "COMMON",
    "UNCOMMON",
    "RARE",
    "EPIC",
    "LEGENDARY",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuality(Quality e) {
  if (::flatbuffers::IsOutRange(e, Quality_NONE, Quality_LEGENDARY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuality()[index];
}

enum Rarity : int32_t {
  Rarity_NeverPick = 0,
  Rarity_Rare = 200,
  Rarity_Normal = 1000,
  Rarity_Common = 2000,
  Rarity_MIN = Rarity_NeverPick,
  Rarity_MAX = Rarity_Common
};

inline const Rarity (&EnumValuesRarity())[4] {
  static const Rarity values[] = {
    Rarity_NeverPick,
    Rarity_Rare,
    Rarity_Normal,
    Rarity_Common
  };
  return values;
}

inline const char *EnumNameRarity(Rarity e) {
  switch (e) {
    case Rarity_NeverPick: return "NeverPick";
    case Rarity_Rare: return "Rare";
    case Rarity_Normal: return "Normal";
    case Rarity_Common: return "Common";
    default: return "";
  }
}

enum SceneNpcState : int32_t {
  SceneNpcState_IDLE = 0,
  SceneNpcState_COLLECTED = 1,
  SceneNpcState_ACTIVATED = 2,
  SceneNpcState_DESTROYED = 3,
  SceneNpcState_MIN = SceneNpcState_IDLE,
  SceneNpcState_MAX = SceneNpcState_DESTROYED
};

inline const SceneNpcState (&EnumValuesSceneNpcState())[4] {
  static const SceneNpcState values[] = {
    SceneNpcState_IDLE,
    SceneNpcState_COLLECTED,
    SceneNpcState_ACTIVATED,
    SceneNpcState_DESTROYED
  };
  return values;
}

inline const char * const *EnumNamesSceneNpcState() {
  static const char * const names[5] = {
    "IDLE",
    "COLLECTED",
    "ACTIVATED",
    "DESTROYED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSceneNpcState(SceneNpcState e) {
  if (::flatbuffers::IsOutRange(e, SceneNpcState_IDLE, SceneNpcState_DESTROYED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSceneNpcState()[index];
}

enum SceneNpcType : int32_t {
  SceneNpcType_NONE = 0,
  SceneNpcType_SILVER = 1,
  SceneNpcType_GOLDEN = 2,
  SceneNpcType_COIN = 3,
  SceneNpcType_BUDDHA = 4,
  SceneNpcType_STAR = 5,
  SceneNpcType_MOTE = 6,
  SceneNpcType_ROBO = 7,
  SceneNpcType_REWARD = 8,
  SceneNpcType_FIXED_RUSH_OBJ = 9,
  SceneNpcType_MIN = SceneNpcType_NONE,
  SceneNpcType_MAX = SceneNpcType_FIXED_RUSH_OBJ
};

inline const SceneNpcType (&EnumValuesSceneNpcType())[10] {
  static const SceneNpcType values[] = {
    SceneNpcType_NONE,
    SceneNpcType_SILVER,
    SceneNpcType_GOLDEN,
    SceneNpcType_COIN,
    SceneNpcType_BUDDHA,
    SceneNpcType_STAR,
    SceneNpcType_MOTE,
    SceneNpcType_ROBO,
    SceneNpcType_REWARD,
    SceneNpcType_FIXED_RUSH_OBJ
  };
  return values;
}

inline const char * const *EnumNamesSceneNpcType() {
  static const char * const names[11] = {
    "NONE",
    "SILVER",
    "GOLDEN",
    "COIN",
    "BUDDHA",
    "STAR",
    "MOTE",
    "ROBO",
    "REWARD",
    "FIXED_RUSH_OBJ",
    nullptr
  };
  return names;
}

inline const char *EnumNameSceneNpcType(SceneNpcType e) {
  if (::flatbuffers::IsOutRange(e, SceneNpcType_NONE, SceneNpcType_FIXED_RUSH_OBJ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSceneNpcType()[index];
}

enum SkillEffectType : int32_t {
  SkillEffectType_NONE = 0,
  SkillEffectType_STUN = 1,
  SkillEffectType_MIN = SkillEffectType_NONE,
  SkillEffectType_MAX = SkillEffectType_STUN
};

inline const SkillEffectType (&EnumValuesSkillEffectType())[2] {
  static const SkillEffectType values[] = {
    SkillEffectType_NONE,
    SkillEffectType_STUN
  };
  return values;
}

inline const char * const *EnumNamesSkillEffectType() {
  static const char * const names[3] = {
    "NONE",
    "STUN",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillEffectType(SkillEffectType e) {
  if (::flatbuffers::IsOutRange(e, SkillEffectType_NONE, SkillEffectType_STUN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillEffectType()[index];
}

enum SkillOpType : int32_t {
  SkillOpType_NONE = 0,
  SkillOpType_RELEASE = 1,
  SkillOpType_START = 2,
  SkillOpType_FINISH = 3,
  SkillOpType_MIN = SkillOpType_NONE,
  SkillOpType_MAX = SkillOpType_FINISH
};

inline const SkillOpType (&EnumValuesSkillOpType())[4] {
  static const SkillOpType values[] = {
    SkillOpType_NONE,
    SkillOpType_RELEASE,
    SkillOpType_START,
    SkillOpType_FINISH
  };
  return values;
}

inline const char * const *EnumNamesSkillOpType() {
  static const char * const names[5] = {
    "NONE",
    "RELEASE",
    "START",
    "FINISH",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillOpType(SkillOpType e) {
  if (::flatbuffers::IsOutRange(e, SkillOpType_NONE, SkillOpType_FINISH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillOpType()[index];
}

enum SkillTargetType : int32_t {
  SkillTargetType_NONE = 0,
  SkillTargetType_MAX_ALERT = 1,
  SkillTargetType_MIN = SkillTargetType_NONE,
  SkillTargetType_MAX = SkillTargetType_MAX_ALERT
};

inline const SkillTargetType (&EnumValuesSkillTargetType())[2] {
  static const SkillTargetType values[] = {
    SkillTargetType_NONE,
    SkillTargetType_MAX_ALERT
  };
  return values;
}

inline const char * const *EnumNamesSkillTargetType() {
  static const char * const names[3] = {
    "NONE",
    "MAX_ALERT",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillTargetType(SkillTargetType e) {
  if (::flatbuffers::IsOutRange(e, SkillTargetType_NONE, SkillTargetType_MAX_ALERT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillTargetType()[index];
}

enum SkillType : int32_t {
  SkillType_NONE = 0,
  SkillType_TAKE_OFF = 1,
  SkillType_HOVER = 2,
  SkillType_SPURT = 3,
  SkillType_BURST_SPURT = 4,
  SkillType_RISE_UP = 5,
  SkillType_YELL = 6,
  SkillType_AIM_ATTACK = 7,
  SkillType_MIN = SkillType_NONE,
  SkillType_MAX = SkillType_AIM_ATTACK
};

inline const SkillType (&EnumValuesSkillType())[8] {
  static const SkillType values[] = {
    SkillType_NONE,
    SkillType_TAKE_OFF,
    SkillType_HOVER,
    SkillType_SPURT,
    SkillType_BURST_SPURT,
    SkillType_RISE_UP,
    SkillType_YELL,
    SkillType_AIM_ATTACK
  };
  return values;
}

inline const char * const *EnumNamesSkillType() {
  static const char * const names[9] = {
    "NONE",
    "TAKE_OFF",
    "HOVER",
    "SPURT",
    "BURST_SPURT",
    "RISE_UP",
    "YELL",
    "AIM_ATTACK",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillType(SkillType e) {
  if (::flatbuffers::IsOutRange(e, SkillType_NONE, SkillType_AIM_ATTACK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillType()[index];
}

enum TaskState : int32_t {
  TaskState_IDLE = 0,
  TaskState_UNLOCKED = 1,
  TaskState_UNACCEPTED = 2,
  TaskState_PROCESSING = 3,
  TaskState_TIMEOUT = 4,
  TaskState_TERMINATED = 5,
  TaskState_REWARDED = 6,
  TaskState_MIN = TaskState_IDLE,
  TaskState_MAX = TaskState_REWARDED
};

inline const TaskState (&EnumValuesTaskState())[7] {
  static const TaskState values[] = {
    TaskState_IDLE,
    TaskState_UNLOCKED,
    TaskState_UNACCEPTED,
    TaskState_PROCESSING,
    TaskState_TIMEOUT,
    TaskState_TERMINATED,
    TaskState_REWARDED
  };
  return values;
}

inline const char * const *EnumNamesTaskState() {
  static const char * const names[8] = {
    "IDLE",
    "UNLOCKED",
    "UNACCEPTED",
    "PROCESSING",
    "TIMEOUT",
    "TERMINATED",
    "REWARDED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTaskState(TaskState e) {
  if (::flatbuffers::IsOutRange(e, TaskState_IDLE, TaskState_REWARDED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTaskState()[index];
}

enum TaskType : int32_t {
  TaskType_NONE = 0,
  TaskType_MAIN = 1,
  TaskType_SIDE = 2,
  TaskType_DAILY = 3,
  TaskType_WEEKLY = 4,
  TaskType_MONTHLY = 5,
  TaskType_REGION = 6,
  TaskType_NORMAL = 100,
  TaskType_MIN = TaskType_NONE,
  TaskType_MAX = TaskType_NORMAL
};

inline const TaskType (&EnumValuesTaskType())[8] {
  static const TaskType values[] = {
    TaskType_NONE,
    TaskType_MAIN,
    TaskType_SIDE,
    TaskType_DAILY,
    TaskType_WEEKLY,
    TaskType_MONTHLY,
    TaskType_REGION,
    TaskType_NORMAL
  };
  return values;
}

inline const char *EnumNameTaskType(TaskType e) {
  switch (e) {
    case TaskType_NONE: return "NONE";
    case TaskType_MAIN: return "MAIN";
    case TaskType_SIDE: return "SIDE";
    case TaskType_DAILY: return "DAILY";
    case TaskType_WEEKLY: return "WEEKLY";
    case TaskType_MONTHLY: return "MONTHLY";
    case TaskType_REGION: return "REGION";
    case TaskType_NORMAL: return "NORMAL";
    default: return "";
  }
}

enum Test : int32_t {
  Test_e1 = 0,
  Test_e2 = 1,
  Test_MIN = Test_e1,
  Test_MAX = Test_e2
};

inline const Test (&EnumValuesTest())[2] {
  static const Test values[] = {
    Test_e1,
    Test_e2
  };
  return values;
}

inline const char * const *EnumNamesTest() {
  static const char * const names[3] = {
    "e1",
    "e2",
    nullptr
  };
  return names;
}

inline const char *EnumNameTest(Test e) {
  if (::flatbuffers::IsOutRange(e, Test_e1, Test_e2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTest()[index];
}

enum TextDisplayType : int32_t {
  TextDisplayType_NONE = 0,
  TextDisplayType_OVERRIDE = 1,
  TextDisplayType_ADDICTIVE = 2,
  TextDisplayType_MIN = TextDisplayType_NONE,
  TextDisplayType_MAX = TextDisplayType_ADDICTIVE
};

inline const TextDisplayType (&EnumValuesTextDisplayType())[3] {
  static const TextDisplayType values[] = {
    TextDisplayType_NONE,
    TextDisplayType_OVERRIDE,
    TextDisplayType_ADDICTIVE
  };
  return values;
}

inline const char * const *EnumNamesTextDisplayType() {
  static const char * const names[4] = {
    "NONE",
    "OVERRIDE",
    "ADDICTIVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextDisplayType(TextDisplayType e) {
  if (::flatbuffers::IsOutRange(e, TextDisplayType_NONE, TextDisplayType_ADDICTIVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextDisplayType()[index];
}

enum ThingType : int32_t {
  ThingType_NONE = 0,
  ThingType_PAY_COIN = 1,
  ThingType_HARD_COIN = 2,
  ThingType_SOFT_COIN = 3,
  ThingType_ITEM = 4,
  ThingType_INSTRUMENT = 5,
  ThingType_MIN = ThingType_NONE,
  ThingType_MAX = ThingType_INSTRUMENT
};

inline const ThingType (&EnumValuesThingType())[6] {
  static const ThingType values[] = {
    ThingType_NONE,
    ThingType_PAY_COIN,
    ThingType_HARD_COIN,
    ThingType_SOFT_COIN,
    ThingType_ITEM,
    ThingType_INSTRUMENT
  };
  return values;
}

inline const char * const *EnumNamesThingType() {
  static const char * const names[7] = {
    "NONE",
    "PAY_COIN",
    "HARD_COIN",
    "SOFT_COIN",
    "ITEM",
    "INSTRUMENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameThingType(ThingType e) {
  if (::flatbuffers::IsOutRange(e, ThingType_NONE, ThingType_INSTRUMENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesThingType()[index];
}

enum UnlockEventConditionType : int32_t {
  UnlockEventConditionType_NONE = 0,
  UnlockEventConditionType_HOLD_X_ITEM_Y_COUNT = 1,
  UnlockEventConditionType_PLAYER_X_ATTR_Y_VALUE = 2,
  UnlockEventConditionType_UNLOCK_EVENT_X = 3,
  UnlockEventConditionType_ACCEPT_X_TASK = 4,
  UnlockEventConditionType_FINISH_X_TASK = 5,
  UnlockEventConditionType_MIN = UnlockEventConditionType_NONE,
  UnlockEventConditionType_MAX = UnlockEventConditionType_FINISH_X_TASK
};

inline const UnlockEventConditionType (&EnumValuesUnlockEventConditionType())[6] {
  static const UnlockEventConditionType values[] = {
    UnlockEventConditionType_NONE,
    UnlockEventConditionType_HOLD_X_ITEM_Y_COUNT,
    UnlockEventConditionType_PLAYER_X_ATTR_Y_VALUE,
    UnlockEventConditionType_UNLOCK_EVENT_X,
    UnlockEventConditionType_ACCEPT_X_TASK,
    UnlockEventConditionType_FINISH_X_TASK
  };
  return values;
}

inline const char * const *EnumNamesUnlockEventConditionType() {
  static const char * const names[7] = {
    "NONE",
    "HOLD_X_ITEM_Y_COUNT",
    "PLAYER_X_ATTR_Y_VALUE",
    "UNLOCK_EVENT_X",
    "ACCEPT_X_TASK",
    "FINISH_X_TASK",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnlockEventConditionType(UnlockEventConditionType e) {
  if (::flatbuffers::IsOutRange(e, UnlockEventConditionType_NONE, UnlockEventConditionType_FINISH_X_TASK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnlockEventConditionType()[index];
}

enum Weather : int32_t {
  Weather_NONE = 0,
  Weather_SUNNY = 1,
  Weather_RAINY = 2,
  Weather_MIN = Weather_NONE,
  Weather_MAX = Weather_RAINY
};

inline const Weather (&EnumValuesWeather())[3] {
  static const Weather values[] = {
    Weather_NONE,
    Weather_SUNNY,
    Weather_RAINY
  };
  return values;
}

inline const char * const *EnumNamesWeather() {
  static const char * const names[4] = {
    "NONE",
    "SUNNY",
    "RAINY",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeather(Weather e) {
  if (::flatbuffers::IsOutRange(e, Weather_NONE, Weather_RAINY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeather()[index];
}

enum WorldAnimalMood : int32_t {
  WorldAnimalMood_NONE = 0,
  WorldAnimalMood_SAD = 1,
  WorldAnimalMood_ANGER = 2,
  WorldAnimalMood_DEPRESSION = 3,
  WorldAnimalMood_ANXIETY = 4,
  WorldAnimalMood_MAXIMUM = 5,
  WorldAnimalMood_MIN = WorldAnimalMood_NONE,
  WorldAnimalMood_MAX = WorldAnimalMood_MAXIMUM
};

inline const WorldAnimalMood (&EnumValuesWorldAnimalMood())[6] {
  static const WorldAnimalMood values[] = {
    WorldAnimalMood_NONE,
    WorldAnimalMood_SAD,
    WorldAnimalMood_ANGER,
    WorldAnimalMood_DEPRESSION,
    WorldAnimalMood_ANXIETY,
    WorldAnimalMood_MAXIMUM
  };
  return values;
}

inline const char * const *EnumNamesWorldAnimalMood() {
  static const char * const names[7] = {
    "NONE",
    "SAD",
    "ANGER",
    "DEPRESSION",
    "ANXIETY",
    "MAXIMUM",
    nullptr
  };
  return names;
}

inline const char *EnumNameWorldAnimalMood(WorldAnimalMood e) {
  if (::flatbuffers::IsOutRange(e, WorldAnimalMood_NONE, WorldAnimalMood_MAXIMUM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWorldAnimalMood()[index];
}

enum ETextIdAlias : int32_t {
  ETextIdAlias_Time_Day = 1,
  ETextIdAlias_Time_Hour = 2,
  ETextIdAlias_Time_Minute = 3,
  ETextIdAlias_Time_Second = 4,
  ETextIdAlias_COMMON_DIALOG_TITLE = 5,
  ETextIdAlias_COMMON_CONFIRM_TEXT = 6,
  ETextIdAlias_COMMON_CANCEL_TEXT = 7,
  ETextIdAlias_LOGIN_ERR_BAD_WORD = 1000,
  ETextIdAlias_LOGIN_ERR_ILLEGAL_LEN = 1001,
  ETextIdAlias_LOGIN_ERR_ILLEGAL_CHAR = 1002,
  ETextIdAlias_LOGIN_ERR_DUPLICATED_NAME = 1003,
  ETextIdAlias_LOGIN_ACCOUNT_IS_EMPTY = 1004,
  ETextIdAlias_LOGIN_CLIENT_IS_ABANDON = 1005,
  ETextIdAlias_ERR_DISCONNECT = 2000,
  ETextIdAlias_Interact_Calm = 9001,
  ETextIdAlias_Interact_Fish = 9002,
  ETextIdAlias_Interact_Help = 9003,
  ETextIdAlias_Interact_Recycle = 9004,
  ETextIdAlias_Interact_Renew = 9005,
  ETextIdAlias_Interact_Park = 9006,
  ETextIdAlias_Interact_Sell = 9007,
  ETextIdAlias_Interact_Collect = 9008,
  ETextIdAlias_Interact_Sacrifice = 9009,
  ETextIdAlias_Common_HelpCalm_Tip = 9100,
  ETextIdAlias_Cook_NotCooked = 10000,
  ETextIdAlias_Cook_Cook = 10001,
  ETextIdAlias_Cook_Throw = 10002,
  ETextIdAlias_Cook_Get = 10003,
  ETextIdAlias_Cook_OtherIsEatting = 10004,
  ETextIdAlias_Parking_Title = 10101,
  ETextIdAlias_Parking_UnitPrice = 10102,
  ETextIdAlias_Parking_TotalPrice = 10103,
  ETextIdAlias_Parking_RemainTimeNotice = 10104,
  ETextIdAlias_Parking_TimeOverNotice = 10105,
  ETextIdAlias_Parking_LackCoinNotice = 10106,
  ETextIdAlias_Parking_RecycleNotice = 10107,
  ETextIdAlias_CHAT_ERR_EMPTY_MESSAGE = 10200,
  ETextIdAlias_Backpack_Title = 10301,
  ETextIdAlias_Backpack_ItemUse = 10302,
  ETextIdAlias_Animal_CalmReward_UpperLimit = 10401,
  ETextIdAlias_Animal_HelpCalmReward_UpperLimit = 10402,
  ETextIdAlias_Aniaml_Warn_No_MusicalInstrument = 10403,
  ETextIdAlias_Animal_Warn_NotEnoughMaxEnergy = 10404,
  ETextIdAlias_Animal_Warn_TeamIsFull = 10405,
  ETextIdAlias_MIN = ETextIdAlias_Time_Day,
  ETextIdAlias_MAX = ETextIdAlias_Animal_Warn_TeamIsFull
};

inline const ETextIdAlias (&EnumValuesETextIdAlias())[44] {
  static const ETextIdAlias values[] = {
    ETextIdAlias_Time_Day,
    ETextIdAlias_Time_Hour,
    ETextIdAlias_Time_Minute,
    ETextIdAlias_Time_Second,
    ETextIdAlias_COMMON_DIALOG_TITLE,
    ETextIdAlias_COMMON_CONFIRM_TEXT,
    ETextIdAlias_COMMON_CANCEL_TEXT,
    ETextIdAlias_LOGIN_ERR_BAD_WORD,
    ETextIdAlias_LOGIN_ERR_ILLEGAL_LEN,
    ETextIdAlias_LOGIN_ERR_ILLEGAL_CHAR,
    ETextIdAlias_LOGIN_ERR_DUPLICATED_NAME,
    ETextIdAlias_LOGIN_ACCOUNT_IS_EMPTY,
    ETextIdAlias_LOGIN_CLIENT_IS_ABANDON,
    ETextIdAlias_ERR_DISCONNECT,
    ETextIdAlias_Interact_Calm,
    ETextIdAlias_Interact_Fish,
    ETextIdAlias_Interact_Help,
    ETextIdAlias_Interact_Recycle,
    ETextIdAlias_Interact_Renew,
    ETextIdAlias_Interact_Park,
    ETextIdAlias_Interact_Sell,
    ETextIdAlias_Interact_Collect,
    ETextIdAlias_Interact_Sacrifice,
    ETextIdAlias_Common_HelpCalm_Tip,
    ETextIdAlias_Cook_NotCooked,
    ETextIdAlias_Cook_Cook,
    ETextIdAlias_Cook_Throw,
    ETextIdAlias_Cook_Get,
    ETextIdAlias_Cook_OtherIsEatting,
    ETextIdAlias_Parking_Title,
    ETextIdAlias_Parking_UnitPrice,
    ETextIdAlias_Parking_TotalPrice,
    ETextIdAlias_Parking_RemainTimeNotice,
    ETextIdAlias_Parking_TimeOverNotice,
    ETextIdAlias_Parking_LackCoinNotice,
    ETextIdAlias_Parking_RecycleNotice,
    ETextIdAlias_CHAT_ERR_EMPTY_MESSAGE,
    ETextIdAlias_Backpack_Title,
    ETextIdAlias_Backpack_ItemUse,
    ETextIdAlias_Animal_CalmReward_UpperLimit,
    ETextIdAlias_Animal_HelpCalmReward_UpperLimit,
    ETextIdAlias_Aniaml_Warn_No_MusicalInstrument,
    ETextIdAlias_Animal_Warn_NotEnoughMaxEnergy,
    ETextIdAlias_Animal_Warn_TeamIsFull
  };
  return values;
}

inline const char *EnumNameETextIdAlias(ETextIdAlias e) {
  switch (e) {
    case ETextIdAlias_Time_Day: return "Time_Day";
    case ETextIdAlias_Time_Hour: return "Time_Hour";
    case ETextIdAlias_Time_Minute: return "Time_Minute";
    case ETextIdAlias_Time_Second: return "Time_Second";
    case ETextIdAlias_COMMON_DIALOG_TITLE: return "COMMON_DIALOG_TITLE";
    case ETextIdAlias_COMMON_CONFIRM_TEXT: return "COMMON_CONFIRM_TEXT";
    case ETextIdAlias_COMMON_CANCEL_TEXT: return "COMMON_CANCEL_TEXT";
    case ETextIdAlias_LOGIN_ERR_BAD_WORD: return "LOGIN_ERR_BAD_WORD";
    case ETextIdAlias_LOGIN_ERR_ILLEGAL_LEN: return "LOGIN_ERR_ILLEGAL_LEN";
    case ETextIdAlias_LOGIN_ERR_ILLEGAL_CHAR: return "LOGIN_ERR_ILLEGAL_CHAR";
    case ETextIdAlias_LOGIN_ERR_DUPLICATED_NAME: return "LOGIN_ERR_DUPLICATED_NAME";
    case ETextIdAlias_LOGIN_ACCOUNT_IS_EMPTY: return "LOGIN_ACCOUNT_IS_EMPTY";
    case ETextIdAlias_LOGIN_CLIENT_IS_ABANDON: return "LOGIN_CLIENT_IS_ABANDON";
    case ETextIdAlias_ERR_DISCONNECT: return "ERR_DISCONNECT";
    case ETextIdAlias_Interact_Calm: return "Interact_Calm";
    case ETextIdAlias_Interact_Fish: return "Interact_Fish";
    case ETextIdAlias_Interact_Help: return "Interact_Help";
    case ETextIdAlias_Interact_Recycle: return "Interact_Recycle";
    case ETextIdAlias_Interact_Renew: return "Interact_Renew";
    case ETextIdAlias_Interact_Park: return "Interact_Park";
    case ETextIdAlias_Interact_Sell: return "Interact_Sell";
    case ETextIdAlias_Interact_Collect: return "Interact_Collect";
    case ETextIdAlias_Interact_Sacrifice: return "Interact_Sacrifice";
    case ETextIdAlias_Common_HelpCalm_Tip: return "Common_HelpCalm_Tip";
    case ETextIdAlias_Cook_NotCooked: return "Cook_NotCooked";
    case ETextIdAlias_Cook_Cook: return "Cook_Cook";
    case ETextIdAlias_Cook_Throw: return "Cook_Throw";
    case ETextIdAlias_Cook_Get: return "Cook_Get";
    case ETextIdAlias_Cook_OtherIsEatting: return "Cook_OtherIsEatting";
    case ETextIdAlias_Parking_Title: return "Parking_Title";
    case ETextIdAlias_Parking_UnitPrice: return "Parking_UnitPrice";
    case ETextIdAlias_Parking_TotalPrice: return "Parking_TotalPrice";
    case ETextIdAlias_Parking_RemainTimeNotice: return "Parking_RemainTimeNotice";
    case ETextIdAlias_Parking_TimeOverNotice: return "Parking_TimeOverNotice";
    case ETextIdAlias_Parking_LackCoinNotice: return "Parking_LackCoinNotice";
    case ETextIdAlias_Parking_RecycleNotice: return "Parking_RecycleNotice";
    case ETextIdAlias_CHAT_ERR_EMPTY_MESSAGE: return "CHAT_ERR_EMPTY_MESSAGE";
    case ETextIdAlias_Backpack_Title: return "Backpack_Title";
    case ETextIdAlias_Backpack_ItemUse: return "Backpack_ItemUse";
    case ETextIdAlias_Animal_CalmReward_UpperLimit: return "Animal_CalmReward_UpperLimit";
    case ETextIdAlias_Animal_HelpCalmReward_UpperLimit: return "Animal_HelpCalmReward_UpperLimit";
    case ETextIdAlias_Aniaml_Warn_No_MusicalInstrument: return "Aniaml_Warn_No_MusicalInstrument";
    case ETextIdAlias_Animal_Warn_NotEnoughMaxEnergy: return "Animal_Warn_NotEnoughMaxEnergy";
    case ETextIdAlias_Animal_Warn_TeamIsFull: return "Animal_Warn_TeamIsFull";
    default: return "";
  }
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ENUMS_FB_H_

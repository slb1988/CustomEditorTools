// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FISHZONESELECT_FB_H_
#define FLATBUFFERS_GENERATED_FISHZONESELECT_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct FishZoneSelect;
struct FishZoneSelectBuilder;
struct FishZoneSelectT;

struct FishZoneSelectRow;
struct FishZoneSelectRowBuilder;
struct FishZoneSelectRowT;

struct FishZoneSelectT : public ::flatbuffers::NativeTable {
  typedef FishZoneSelect TableType;
  std::vector<std::unique_ptr<fb::FishZoneSelectRowT>> FishZoneSelects{};
  FishZoneSelectT() = default;
  FishZoneSelectT(const FishZoneSelectT &o);
  FishZoneSelectT(FishZoneSelectT&&) FLATBUFFERS_NOEXCEPT = default;
  FishZoneSelectT &operator=(FishZoneSelectT o) FLATBUFFERS_NOEXCEPT;
};

struct FishZoneSelect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FishZoneSelectT NativeTableType;
  typedef FishZoneSelectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FISHZONESELECTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::FishZoneSelectRow>> *FishZoneSelects() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::FishZoneSelectRow>> *>(VT_FISHZONESELECTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FISHZONESELECTS) &&
           verifier.VerifyVector(FishZoneSelects()) &&
           verifier.VerifyVectorOfTables(FishZoneSelects()) &&
           verifier.EndTable();
  }
  FishZoneSelectT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FishZoneSelectT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FishZoneSelect> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FishZoneSelectBuilder {
  typedef FishZoneSelect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FishZoneSelects(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::FishZoneSelectRow>>> FishZoneSelects) {
    fbb_.AddOffset(FishZoneSelect::VT_FISHZONESELECTS, FishZoneSelects);
  }
  explicit FishZoneSelectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FishZoneSelect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FishZoneSelect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FishZoneSelect> CreateFishZoneSelect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::FishZoneSelectRow>>> FishZoneSelects = 0) {
  FishZoneSelectBuilder builder_(_fbb);
  builder_.add_FishZoneSelects(FishZoneSelects);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FishZoneSelect> CreateFishZoneSelectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::FishZoneSelectRow>> *FishZoneSelects = nullptr) {
  auto FishZoneSelects__ = FishZoneSelects ? _fbb.CreateVector<::flatbuffers::Offset<fb::FishZoneSelectRow>>(*FishZoneSelects) : 0;
  return fb::CreateFishZoneSelect(
      _fbb,
      FishZoneSelects__);
}

::flatbuffers::Offset<FishZoneSelect> CreateFishZoneSelect(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FishZoneSelectRowT : public ::flatbuffers::NativeTable {
  typedef FishZoneSelectRow TableType;
  uint32_t Id = 0;
  uint32_t FishZoneId = 0;
  std::string RefreshTime{};
  fb::Weather Weather = fb::Weather_NONE;
  uint32_t Priority = 0;
  std::vector<std::unique_ptr<fb::tuple_uint32_uint32T>> Choose{};
  FishZoneSelectRowT() = default;
  FishZoneSelectRowT(const FishZoneSelectRowT &o);
  FishZoneSelectRowT(FishZoneSelectRowT&&) FLATBUFFERS_NOEXCEPT = default;
  FishZoneSelectRowT &operator=(FishZoneSelectRowT o) FLATBUFFERS_NOEXCEPT;
};

struct FishZoneSelectRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FishZoneSelectRowT NativeTableType;
  typedef FishZoneSelectRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FISHZONEID = 6,
    VT_REFRESHTIME = 8,
    VT_WEATHER = 10,
    VT_PRIORITY = 12,
    VT_CHOOSE = 14
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t FishZoneId() const {
    return GetField<uint32_t>(VT_FISHZONEID, 0);
  }
  const ::flatbuffers::String *RefreshTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFRESHTIME);
  }
  fb::Weather Weather() const {
    return static_cast<fb::Weather>(GetField<int32_t>(VT_WEATHER, 0));
  }
  uint32_t Priority() const {
    return GetField<uint32_t>(VT_PRIORITY, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *Choose() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *>(VT_CHOOSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_FISHZONEID, 4) &&
           VerifyOffset(verifier, VT_REFRESHTIME) &&
           verifier.VerifyString(RefreshTime()) &&
           VerifyField<int32_t>(verifier, VT_WEATHER, 4) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyOffset(verifier, VT_CHOOSE) &&
           verifier.VerifyVector(Choose()) &&
           verifier.VerifyVectorOfTables(Choose()) &&
           verifier.EndTable();
  }
  FishZoneSelectRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FishZoneSelectRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FishZoneSelectRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FishZoneSelectRowBuilder {
  typedef FishZoneSelectRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(FishZoneSelectRow::VT_ID, Id, 0);
  }
  void add_FishZoneId(uint32_t FishZoneId) {
    fbb_.AddElement<uint32_t>(FishZoneSelectRow::VT_FISHZONEID, FishZoneId, 0);
  }
  void add_RefreshTime(::flatbuffers::Offset<::flatbuffers::String> RefreshTime) {
    fbb_.AddOffset(FishZoneSelectRow::VT_REFRESHTIME, RefreshTime);
  }
  void add_Weather(fb::Weather Weather) {
    fbb_.AddElement<int32_t>(FishZoneSelectRow::VT_WEATHER, static_cast<int32_t>(Weather), 0);
  }
  void add_Priority(uint32_t Priority) {
    fbb_.AddElement<uint32_t>(FishZoneSelectRow::VT_PRIORITY, Priority, 0);
  }
  void add_Choose(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>> Choose) {
    fbb_.AddOffset(FishZoneSelectRow::VT_CHOOSE, Choose);
  }
  explicit FishZoneSelectRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FishZoneSelectRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FishZoneSelectRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FishZoneSelectRow> CreateFishZoneSelectRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    uint32_t FishZoneId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RefreshTime = 0,
    fb::Weather Weather = fb::Weather_NONE,
    uint32_t Priority = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>> Choose = 0) {
  FishZoneSelectRowBuilder builder_(_fbb);
  builder_.add_Choose(Choose);
  builder_.add_Priority(Priority);
  builder_.add_Weather(Weather);
  builder_.add_RefreshTime(RefreshTime);
  builder_.add_FishZoneId(FishZoneId);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FishZoneSelectRow> CreateFishZoneSelectRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    uint32_t FishZoneId = 0,
    const char *RefreshTime = nullptr,
    fb::Weather Weather = fb::Weather_NONE,
    uint32_t Priority = 0,
    const std::vector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> *Choose = nullptr) {
  auto RefreshTime__ = RefreshTime ? _fbb.CreateString(RefreshTime) : 0;
  auto Choose__ = Choose ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32>>(*Choose) : 0;
  return fb::CreateFishZoneSelectRow(
      _fbb,
      Id,
      FishZoneId,
      RefreshTime__,
      Weather,
      Priority,
      Choose__);
}

::flatbuffers::Offset<FishZoneSelectRow> CreateFishZoneSelectRow(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FishZoneSelectT::FishZoneSelectT(const FishZoneSelectT &o) {
  FishZoneSelects.reserve(o.FishZoneSelects.size());
  for (const auto &FishZoneSelects_ : o.FishZoneSelects) { FishZoneSelects.emplace_back((FishZoneSelects_) ? new fb::FishZoneSelectRowT(*FishZoneSelects_) : nullptr); }
}

inline FishZoneSelectT &FishZoneSelectT::operator=(FishZoneSelectT o) FLATBUFFERS_NOEXCEPT {
  std::swap(FishZoneSelects, o.FishZoneSelects);
  return *this;
}

inline FishZoneSelectT *FishZoneSelect::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FishZoneSelectT>(new FishZoneSelectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FishZoneSelect::UnPackTo(FishZoneSelectT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = FishZoneSelects(); if (_e) { _o->FishZoneSelects.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->FishZoneSelects[_i]) { _e->Get(_i)->UnPackTo(_o->FishZoneSelects[_i].get(), _resolver); } else { _o->FishZoneSelects[_i] = std::unique_ptr<fb::FishZoneSelectRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->FishZoneSelects.resize(0); } }
}

inline ::flatbuffers::Offset<FishZoneSelect> FishZoneSelect::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFishZoneSelect(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FishZoneSelect> CreateFishZoneSelect(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FishZoneSelectT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _FishZoneSelects = _o->FishZoneSelects.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::FishZoneSelectRow>> (_o->FishZoneSelects.size(), [](size_t i, _VectorArgs *__va) { return CreateFishZoneSelectRow(*__va->__fbb, __va->__o->FishZoneSelects[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateFishZoneSelect(
      _fbb,
      _FishZoneSelects);
}

inline FishZoneSelectRowT::FishZoneSelectRowT(const FishZoneSelectRowT &o)
      : Id(o.Id),
        FishZoneId(o.FishZoneId),
        RefreshTime(o.RefreshTime),
        Weather(o.Weather),
        Priority(o.Priority) {
  Choose.reserve(o.Choose.size());
  for (const auto &Choose_ : o.Choose) { Choose.emplace_back((Choose_) ? new fb::tuple_uint32_uint32T(*Choose_) : nullptr); }
}

inline FishZoneSelectRowT &FishZoneSelectRowT::operator=(FishZoneSelectRowT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(FishZoneId, o.FishZoneId);
  std::swap(RefreshTime, o.RefreshTime);
  std::swap(Weather, o.Weather);
  std::swap(Priority, o.Priority);
  std::swap(Choose, o.Choose);
  return *this;
}

inline FishZoneSelectRowT *FishZoneSelectRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FishZoneSelectRowT>(new FishZoneSelectRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FishZoneSelectRow::UnPackTo(FishZoneSelectRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = FishZoneId(); _o->FishZoneId = _e; }
  { auto _e = RefreshTime(); if (_e) _o->RefreshTime = _e->str(); }
  { auto _e = Weather(); _o->Weather = _e; }
  { auto _e = Priority(); _o->Priority = _e; }
  { auto _e = Choose(); if (_e) { _o->Choose.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->Choose[_i]) { _e->Get(_i)->UnPackTo(_o->Choose[_i].get(), _resolver); } else { _o->Choose[_i] = std::unique_ptr<fb::tuple_uint32_uint32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->Choose.resize(0); } }
}

inline ::flatbuffers::Offset<FishZoneSelectRow> FishZoneSelectRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFishZoneSelectRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FishZoneSelectRow> CreateFishZoneSelectRow(::flatbuffers::FlatBufferBuilder &_fbb, const FishZoneSelectRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FishZoneSelectRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _FishZoneId = _o->FishZoneId;
  auto _RefreshTime = _o->RefreshTime.empty() ? 0 : _fbb.CreateString(_o->RefreshTime);
  auto _Weather = _o->Weather;
  auto _Priority = _o->Priority;
  auto _Choose = _o->Choose.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::tuple_uint32_uint32>> (_o->Choose.size(), [](size_t i, _VectorArgs *__va) { return Createtuple_uint32_uint32(*__va->__fbb, __va->__o->Choose[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateFishZoneSelectRow(
      _fbb,
      _Id,
      _FishZoneId,
      _RefreshTime,
      _Weather,
      _Priority,
      _Choose);
}

inline const fb::FishZoneSelect *GetFishZoneSelect(const void *buf) {
  return ::flatbuffers::GetRoot<fb::FishZoneSelect>(buf);
}

inline const fb::FishZoneSelect *GetSizePrefixedFishZoneSelect(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::FishZoneSelect>(buf);
}

inline bool VerifyFishZoneSelectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::FishZoneSelect>(nullptr);
}

inline bool VerifySizePrefixedFishZoneSelectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::FishZoneSelect>(nullptr);
}

inline void FinishFishZoneSelectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::FishZoneSelect> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFishZoneSelectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::FishZoneSelect> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::FishZoneSelectT> UnPackFishZoneSelect(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::FishZoneSelectT>(GetFishZoneSelect(buf)->UnPack(res));
}

inline std::unique_ptr<fb::FishZoneSelectT> UnPackSizePrefixedFishZoneSelect(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::FishZoneSelectT>(GetSizePrefixedFishZoneSelect(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_FISHZONESELECT_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BASICTYPE_FB_H_
#define FLATBUFFERS_GENERATED_BASICTYPE_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct BasicType;
struct BasicTypeBuilder;
struct BasicTypeT;

struct BasicTypeRow;
struct BasicTypeRowBuilder;
struct BasicTypeRowT;

struct BasicTypeT : public ::flatbuffers::NativeTable {
  typedef BasicType TableType;
  std::vector<std::unique_ptr<fb::BasicTypeRowT>> BasicTypes{};
  BasicTypeT() = default;
  BasicTypeT(const BasicTypeT &o);
  BasicTypeT(BasicTypeT&&) FLATBUFFERS_NOEXCEPT = default;
  BasicTypeT &operator=(BasicTypeT o) FLATBUFFERS_NOEXCEPT;
};

struct BasicType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BasicTypeT NativeTableType;
  typedef BasicTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICTYPES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::BasicTypeRow>> *BasicTypes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::BasicTypeRow>> *>(VT_BASICTYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICTYPES) &&
           verifier.VerifyVector(BasicTypes()) &&
           verifier.VerifyVectorOfTables(BasicTypes()) &&
           verifier.EndTable();
  }
  BasicTypeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BasicTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BasicType> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BasicTypeBuilder {
  typedef BasicType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_BasicTypes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::BasicTypeRow>>> BasicTypes) {
    fbb_.AddOffset(BasicType::VT_BASICTYPES, BasicTypes);
  }
  explicit BasicTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BasicType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BasicType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BasicType> CreateBasicType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::BasicTypeRow>>> BasicTypes = 0) {
  BasicTypeBuilder builder_(_fbb);
  builder_.add_BasicTypes(BasicTypes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BasicType> CreateBasicTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::BasicTypeRow>> *BasicTypes = nullptr) {
  auto BasicTypes__ = BasicTypes ? _fbb.CreateVector<::flatbuffers::Offset<fb::BasicTypeRow>>(*BasicTypes) : 0;
  return fb::CreateBasicType(
      _fbb,
      BasicTypes__);
}

::flatbuffers::Offset<BasicType> CreateBasicType(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BasicTypeRowT : public ::flatbuffers::NativeTable {
  typedef BasicTypeRow TableType;
  int32_t Id = 0;
  int32_t VInt = 0;
  int64_t VInt64 = 0;
  int64_t VDate = 0;
  float VFloat = 0.0f;
  double VDouble = 0.0;
  std::string VString{};
};

struct BasicTypeRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BasicTypeRowT NativeTableType;
  typedef BasicTypeRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VINT = 6,
    VT_VINT64 = 8,
    VT_VDATE = 10,
    VT_VFLOAT = 12,
    VT_VDOUBLE = 14,
    VT_VSTRING = 16
  };
  int32_t Id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t VInt() const {
    return GetField<int32_t>(VT_VINT, 0);
  }
  int64_t VInt64() const {
    return GetField<int64_t>(VT_VINT64, 0);
  }
  int64_t VDate() const {
    return GetField<int64_t>(VT_VDATE, 0);
  }
  float VFloat() const {
    return GetField<float>(VT_VFLOAT, 0.0f);
  }
  double VDouble() const {
    return GetField<double>(VT_VDOUBLE, 0.0);
  }
  const ::flatbuffers::String *VString() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VSTRING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_VINT, 4) &&
           VerifyField<int64_t>(verifier, VT_VINT64, 8) &&
           VerifyField<int64_t>(verifier, VT_VDATE, 8) &&
           VerifyField<float>(verifier, VT_VFLOAT, 4) &&
           VerifyField<double>(verifier, VT_VDOUBLE, 8) &&
           VerifyOffset(verifier, VT_VSTRING) &&
           verifier.VerifyString(VString()) &&
           verifier.EndTable();
  }
  BasicTypeRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BasicTypeRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BasicTypeRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BasicTypeRowBuilder {
  typedef BasicTypeRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(int32_t Id) {
    fbb_.AddElement<int32_t>(BasicTypeRow::VT_ID, Id, 0);
  }
  void add_VInt(int32_t VInt) {
    fbb_.AddElement<int32_t>(BasicTypeRow::VT_VINT, VInt, 0);
  }
  void add_VInt64(int64_t VInt64) {
    fbb_.AddElement<int64_t>(BasicTypeRow::VT_VINT64, VInt64, 0);
  }
  void add_VDate(int64_t VDate) {
    fbb_.AddElement<int64_t>(BasicTypeRow::VT_VDATE, VDate, 0);
  }
  void add_VFloat(float VFloat) {
    fbb_.AddElement<float>(BasicTypeRow::VT_VFLOAT, VFloat, 0.0f);
  }
  void add_VDouble(double VDouble) {
    fbb_.AddElement<double>(BasicTypeRow::VT_VDOUBLE, VDouble, 0.0);
  }
  void add_VString(::flatbuffers::Offset<::flatbuffers::String> VString) {
    fbb_.AddOffset(BasicTypeRow::VT_VSTRING, VString);
  }
  explicit BasicTypeRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BasicTypeRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BasicTypeRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BasicTypeRow> CreateBasicTypeRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t VInt = 0,
    int64_t VInt64 = 0,
    int64_t VDate = 0,
    float VFloat = 0.0f,
    double VDouble = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> VString = 0) {
  BasicTypeRowBuilder builder_(_fbb);
  builder_.add_VDouble(VDouble);
  builder_.add_VDate(VDate);
  builder_.add_VInt64(VInt64);
  builder_.add_VString(VString);
  builder_.add_VFloat(VFloat);
  builder_.add_VInt(VInt);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BasicTypeRow> CreateBasicTypeRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Id = 0,
    int32_t VInt = 0,
    int64_t VInt64 = 0,
    int64_t VDate = 0,
    float VFloat = 0.0f,
    double VDouble = 0.0,
    const char *VString = nullptr) {
  auto VString__ = VString ? _fbb.CreateString(VString) : 0;
  return fb::CreateBasicTypeRow(
      _fbb,
      Id,
      VInt,
      VInt64,
      VDate,
      VFloat,
      VDouble,
      VString__);
}

::flatbuffers::Offset<BasicTypeRow> CreateBasicTypeRow(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BasicTypeT::BasicTypeT(const BasicTypeT &o) {
  BasicTypes.reserve(o.BasicTypes.size());
  for (const auto &BasicTypes_ : o.BasicTypes) { BasicTypes.emplace_back((BasicTypes_) ? new fb::BasicTypeRowT(*BasicTypes_) : nullptr); }
}

inline BasicTypeT &BasicTypeT::operator=(BasicTypeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(BasicTypes, o.BasicTypes);
  return *this;
}

inline BasicTypeT *BasicType::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BasicTypeT>(new BasicTypeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BasicType::UnPackTo(BasicTypeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = BasicTypes(); if (_e) { _o->BasicTypes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->BasicTypes[_i]) { _e->Get(_i)->UnPackTo(_o->BasicTypes[_i].get(), _resolver); } else { _o->BasicTypes[_i] = std::unique_ptr<fb::BasicTypeRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->BasicTypes.resize(0); } }
}

inline ::flatbuffers::Offset<BasicType> BasicType::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBasicType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BasicType> CreateBasicType(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BasicTypeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _BasicTypes = _o->BasicTypes.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::BasicTypeRow>> (_o->BasicTypes.size(), [](size_t i, _VectorArgs *__va) { return CreateBasicTypeRow(*__va->__fbb, __va->__o->BasicTypes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreateBasicType(
      _fbb,
      _BasicTypes);
}

inline BasicTypeRowT *BasicTypeRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BasicTypeRowT>(new BasicTypeRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BasicTypeRow::UnPackTo(BasicTypeRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = VInt(); _o->VInt = _e; }
  { auto _e = VInt64(); _o->VInt64 = _e; }
  { auto _e = VDate(); _o->VDate = _e; }
  { auto _e = VFloat(); _o->VFloat = _e; }
  { auto _e = VDouble(); _o->VDouble = _e; }
  { auto _e = VString(); if (_e) _o->VString = _e->str(); }
}

inline ::flatbuffers::Offset<BasicTypeRow> BasicTypeRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBasicTypeRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BasicTypeRow> CreateBasicTypeRow(::flatbuffers::FlatBufferBuilder &_fbb, const BasicTypeRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BasicTypeRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _VInt = _o->VInt;
  auto _VInt64 = _o->VInt64;
  auto _VDate = _o->VDate;
  auto _VFloat = _o->VFloat;
  auto _VDouble = _o->VDouble;
  auto _VString = _o->VString.empty() ? 0 : _fbb.CreateString(_o->VString);
  return fb::CreateBasicTypeRow(
      _fbb,
      _Id,
      _VInt,
      _VInt64,
      _VDate,
      _VFloat,
      _VDouble,
      _VString);
}

inline const fb::BasicType *GetBasicType(const void *buf) {
  return ::flatbuffers::GetRoot<fb::BasicType>(buf);
}

inline const fb::BasicType *GetSizePrefixedBasicType(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::BasicType>(buf);
}

inline bool VerifyBasicTypeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::BasicType>(nullptr);
}

inline bool VerifySizePrefixedBasicTypeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::BasicType>(nullptr);
}

inline void FinishBasicTypeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::BasicType> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBasicTypeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::BasicType> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::BasicTypeT> UnPackBasicType(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::BasicTypeT>(GetBasicType(buf)->UnPack(res));
}

inline std::unique_ptr<fb::BasicTypeT> UnPackSizePrefixedBasicType(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::BasicTypeT>(GetSizePrefixedBasicType(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_BASICTYPE_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PLACEABLEITEM_FB_H_
#define FLATBUFFERS_GENERATED_PLACEABLEITEM_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct PlaceableItem;
struct PlaceableItemBuilder;
struct PlaceableItemT;

struct PlaceableItemRow;
struct PlaceableItemRowBuilder;
struct PlaceableItemRowT;

struct PlaceableItemT : public ::flatbuffers::NativeTable {
  typedef PlaceableItem TableType;
  std::vector<std::unique_ptr<fb::PlaceableItemRowT>> PlaceableItems{};
  PlaceableItemT() = default;
  PlaceableItemT(const PlaceableItemT &o);
  PlaceableItemT(PlaceableItemT&&) FLATBUFFERS_NOEXCEPT = default;
  PlaceableItemT &operator=(PlaceableItemT o) FLATBUFFERS_NOEXCEPT;
};

struct PlaceableItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlaceableItemT NativeTableType;
  typedef PlaceableItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLACEABLEITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::PlaceableItemRow>> *PlaceableItems() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::PlaceableItemRow>> *>(VT_PLACEABLEITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLACEABLEITEMS) &&
           verifier.VerifyVector(PlaceableItems()) &&
           verifier.VerifyVectorOfTables(PlaceableItems()) &&
           verifier.EndTable();
  }
  PlaceableItemT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlaceableItemT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlaceableItem> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlaceableItemBuilder {
  typedef PlaceableItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PlaceableItems(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::PlaceableItemRow>>> PlaceableItems) {
    fbb_.AddOffset(PlaceableItem::VT_PLACEABLEITEMS, PlaceableItems);
  }
  explicit PlaceableItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlaceableItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlaceableItem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlaceableItem> CreatePlaceableItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::PlaceableItemRow>>> PlaceableItems = 0) {
  PlaceableItemBuilder builder_(_fbb);
  builder_.add_PlaceableItems(PlaceableItems);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlaceableItem> CreatePlaceableItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::PlaceableItemRow>> *PlaceableItems = nullptr) {
  auto PlaceableItems__ = PlaceableItems ? _fbb.CreateVector<::flatbuffers::Offset<fb::PlaceableItemRow>>(*PlaceableItems) : 0;
  return fb::CreatePlaceableItem(
      _fbb,
      PlaceableItems__);
}

::flatbuffers::Offset<PlaceableItem> CreatePlaceableItem(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlaceableItemRowT : public ::flatbuffers::NativeTable {
  typedef PlaceableItemRow TableType;
  uint32_t Id = 0;
  int32_t Name = 0;
  std::vector<fb::PlaceableTag> Tags{};
  std::vector<fb::PlaceableTag> TagsForRandom{};
  int32_t MaxRandomNum = 0;
  std::string PrefabPath{};
  int32_t Score = 0;
  int32_t Star = 0;
  fb::Rarity BaseRarity = fb::Rarity_NeverPick;
  int32_t Frequency = 0;
  float Challenge = 0.0f;
  int32_t Price = 0;
  int32_t Area = 0;
  bool Enable = false;
};

struct PlaceableItemRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlaceableItemRowT NativeTableType;
  typedef PlaceableItemRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TAGS = 8,
    VT_TAGSFORRANDOM = 10,
    VT_MAXRANDOMNUM = 12,
    VT_PREFABPATH = 14,
    VT_SCORE = 16,
    VT_STAR = 18,
    VT_BASERARITY = 20,
    VT_FREQUENCY = 22,
    VT_CHALLENGE = 24,
    VT_PRICE = 26,
    VT_AREA = 28,
    VT_ENABLE = 30
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t Name() const {
    return GetField<int32_t>(VT_NAME, 0);
  }
  const ::flatbuffers::Vector<int32_t> *Tags() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TAGS);
  }
  const ::flatbuffers::Vector<int32_t> *TagsForRandom() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TAGSFORRANDOM);
  }
  int32_t MaxRandomNum() const {
    return GetField<int32_t>(VT_MAXRANDOMNUM, 0);
  }
  const ::flatbuffers::String *PrefabPath() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREFABPATH);
  }
  int32_t Score() const {
    return GetField<int32_t>(VT_SCORE, 0);
  }
  int32_t Star() const {
    return GetField<int32_t>(VT_STAR, 0);
  }
  fb::Rarity BaseRarity() const {
    return static_cast<fb::Rarity>(GetField<int32_t>(VT_BASERARITY, 0));
  }
  int32_t Frequency() const {
    return GetField<int32_t>(VT_FREQUENCY, 0);
  }
  float Challenge() const {
    return GetField<float>(VT_CHALLENGE, 0.0f);
  }
  int32_t Price() const {
    return GetField<int32_t>(VT_PRICE, 0);
  }
  int32_t Area() const {
    return GetField<int32_t>(VT_AREA, 0);
  }
  bool Enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_NAME, 4) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(Tags()) &&
           VerifyOffset(verifier, VT_TAGSFORRANDOM) &&
           verifier.VerifyVector(TagsForRandom()) &&
           VerifyField<int32_t>(verifier, VT_MAXRANDOMNUM, 4) &&
           VerifyOffset(verifier, VT_PREFABPATH) &&
           verifier.VerifyString(PrefabPath()) &&
           VerifyField<int32_t>(verifier, VT_SCORE, 4) &&
           VerifyField<int32_t>(verifier, VT_STAR, 4) &&
           VerifyField<int32_t>(verifier, VT_BASERARITY, 4) &&
           VerifyField<int32_t>(verifier, VT_FREQUENCY, 4) &&
           VerifyField<float>(verifier, VT_CHALLENGE, 4) &&
           VerifyField<int32_t>(verifier, VT_PRICE, 4) &&
           VerifyField<int32_t>(verifier, VT_AREA, 4) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE, 1) &&
           verifier.EndTable();
  }
  PlaceableItemRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlaceableItemRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlaceableItemRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlaceableItemRowBuilder {
  typedef PlaceableItemRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(PlaceableItemRow::VT_ID, Id, 0);
  }
  void add_Name(int32_t Name) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_NAME, Name, 0);
  }
  void add_Tags(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> Tags) {
    fbb_.AddOffset(PlaceableItemRow::VT_TAGS, Tags);
  }
  void add_TagsForRandom(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TagsForRandom) {
    fbb_.AddOffset(PlaceableItemRow::VT_TAGSFORRANDOM, TagsForRandom);
  }
  void add_MaxRandomNum(int32_t MaxRandomNum) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_MAXRANDOMNUM, MaxRandomNum, 0);
  }
  void add_PrefabPath(::flatbuffers::Offset<::flatbuffers::String> PrefabPath) {
    fbb_.AddOffset(PlaceableItemRow::VT_PREFABPATH, PrefabPath);
  }
  void add_Score(int32_t Score) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_SCORE, Score, 0);
  }
  void add_Star(int32_t Star) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_STAR, Star, 0);
  }
  void add_BaseRarity(fb::Rarity BaseRarity) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_BASERARITY, static_cast<int32_t>(BaseRarity), 0);
  }
  void add_Frequency(int32_t Frequency) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_FREQUENCY, Frequency, 0);
  }
  void add_Challenge(float Challenge) {
    fbb_.AddElement<float>(PlaceableItemRow::VT_CHALLENGE, Challenge, 0.0f);
  }
  void add_Price(int32_t Price) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_PRICE, Price, 0);
  }
  void add_Area(int32_t Area) {
    fbb_.AddElement<int32_t>(PlaceableItemRow::VT_AREA, Area, 0);
  }
  void add_Enable(bool Enable) {
    fbb_.AddElement<uint8_t>(PlaceableItemRow::VT_ENABLE, static_cast<uint8_t>(Enable), 0);
  }
  explicit PlaceableItemRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlaceableItemRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlaceableItemRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlaceableItemRow> CreatePlaceableItemRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    int32_t Name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> Tags = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TagsForRandom = 0,
    int32_t MaxRandomNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PrefabPath = 0,
    int32_t Score = 0,
    int32_t Star = 0,
    fb::Rarity BaseRarity = fb::Rarity_NeverPick,
    int32_t Frequency = 0,
    float Challenge = 0.0f,
    int32_t Price = 0,
    int32_t Area = 0,
    bool Enable = false) {
  PlaceableItemRowBuilder builder_(_fbb);
  builder_.add_Area(Area);
  builder_.add_Price(Price);
  builder_.add_Challenge(Challenge);
  builder_.add_Frequency(Frequency);
  builder_.add_BaseRarity(BaseRarity);
  builder_.add_Star(Star);
  builder_.add_Score(Score);
  builder_.add_PrefabPath(PrefabPath);
  builder_.add_MaxRandomNum(MaxRandomNum);
  builder_.add_TagsForRandom(TagsForRandom);
  builder_.add_Tags(Tags);
  builder_.add_Name(Name);
  builder_.add_Id(Id);
  builder_.add_Enable(Enable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlaceableItemRow> CreatePlaceableItemRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    int32_t Name = 0,
    const std::vector<int32_t> *Tags = nullptr,
    const std::vector<int32_t> *TagsForRandom = nullptr,
    int32_t MaxRandomNum = 0,
    const char *PrefabPath = nullptr,
    int32_t Score = 0,
    int32_t Star = 0,
    fb::Rarity BaseRarity = fb::Rarity_NeverPick,
    int32_t Frequency = 0,
    float Challenge = 0.0f,
    int32_t Price = 0,
    int32_t Area = 0,
    bool Enable = false) {
  auto Tags__ = Tags ? _fbb.CreateVector<int32_t>(*Tags) : 0;
  auto TagsForRandom__ = TagsForRandom ? _fbb.CreateVector<int32_t>(*TagsForRandom) : 0;
  auto PrefabPath__ = PrefabPath ? _fbb.CreateString(PrefabPath) : 0;
  return fb::CreatePlaceableItemRow(
      _fbb,
      Id,
      Name,
      Tags__,
      TagsForRandom__,
      MaxRandomNum,
      PrefabPath__,
      Score,
      Star,
      BaseRarity,
      Frequency,
      Challenge,
      Price,
      Area,
      Enable);
}

::flatbuffers::Offset<PlaceableItemRow> CreatePlaceableItemRow(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PlaceableItemT::PlaceableItemT(const PlaceableItemT &o) {
  PlaceableItems.reserve(o.PlaceableItems.size());
  for (const auto &PlaceableItems_ : o.PlaceableItems) { PlaceableItems.emplace_back((PlaceableItems_) ? new fb::PlaceableItemRowT(*PlaceableItems_) : nullptr); }
}

inline PlaceableItemT &PlaceableItemT::operator=(PlaceableItemT o) FLATBUFFERS_NOEXCEPT {
  std::swap(PlaceableItems, o.PlaceableItems);
  return *this;
}

inline PlaceableItemT *PlaceableItem::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlaceableItemT>(new PlaceableItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlaceableItem::UnPackTo(PlaceableItemT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = PlaceableItems(); if (_e) { _o->PlaceableItems.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->PlaceableItems[_i]) { _e->Get(_i)->UnPackTo(_o->PlaceableItems[_i].get(), _resolver); } else { _o->PlaceableItems[_i] = std::unique_ptr<fb::PlaceableItemRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->PlaceableItems.resize(0); } }
}

inline ::flatbuffers::Offset<PlaceableItem> PlaceableItem::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlaceableItem(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlaceableItem> CreatePlaceableItem(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlaceableItemT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _PlaceableItems = _o->PlaceableItems.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::PlaceableItemRow>> (_o->PlaceableItems.size(), [](size_t i, _VectorArgs *__va) { return CreatePlaceableItemRow(*__va->__fbb, __va->__o->PlaceableItems[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::CreatePlaceableItem(
      _fbb,
      _PlaceableItems);
}

inline PlaceableItemRowT *PlaceableItemRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlaceableItemRowT>(new PlaceableItemRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlaceableItemRow::UnPackTo(PlaceableItemRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = Name(); _o->Name = _e; }
  { auto _e = Tags(); if (_e) { _o->Tags.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Tags[_i] = static_cast<fb::PlaceableTag>(_e->Get(_i)); } } else { _o->Tags.resize(0); } }
  { auto _e = TagsForRandom(); if (_e) { _o->TagsForRandom.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->TagsForRandom[_i] = static_cast<fb::PlaceableTag>(_e->Get(_i)); } } else { _o->TagsForRandom.resize(0); } }
  { auto _e = MaxRandomNum(); _o->MaxRandomNum = _e; }
  { auto _e = PrefabPath(); if (_e) _o->PrefabPath = _e->str(); }
  { auto _e = Score(); _o->Score = _e; }
  { auto _e = Star(); _o->Star = _e; }
  { auto _e = BaseRarity(); _o->BaseRarity = _e; }
  { auto _e = Frequency(); _o->Frequency = _e; }
  { auto _e = Challenge(); _o->Challenge = _e; }
  { auto _e = Price(); _o->Price = _e; }
  { auto _e = Area(); _o->Area = _e; }
  { auto _e = Enable(); _o->Enable = _e; }
}

inline ::flatbuffers::Offset<PlaceableItemRow> PlaceableItemRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlaceableItemRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlaceableItemRow> CreatePlaceableItemRow(::flatbuffers::FlatBufferBuilder &_fbb, const PlaceableItemRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlaceableItemRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _Name = _o->Name;
  auto _Tags = _o->Tags.size() ? _fbb.CreateVectorScalarCast<int32_t>(::flatbuffers::data(_o->Tags), _o->Tags.size()) : 0;
  auto _TagsForRandom = _o->TagsForRandom.size() ? _fbb.CreateVectorScalarCast<int32_t>(::flatbuffers::data(_o->TagsForRandom), _o->TagsForRandom.size()) : 0;
  auto _MaxRandomNum = _o->MaxRandomNum;
  auto _PrefabPath = _o->PrefabPath.empty() ? 0 : _fbb.CreateString(_o->PrefabPath);
  auto _Score = _o->Score;
  auto _Star = _o->Star;
  auto _BaseRarity = _o->BaseRarity;
  auto _Frequency = _o->Frequency;
  auto _Challenge = _o->Challenge;
  auto _Price = _o->Price;
  auto _Area = _o->Area;
  auto _Enable = _o->Enable;
  return fb::CreatePlaceableItemRow(
      _fbb,
      _Id,
      _Name,
      _Tags,
      _TagsForRandom,
      _MaxRandomNum,
      _PrefabPath,
      _Score,
      _Star,
      _BaseRarity,
      _Frequency,
      _Challenge,
      _Price,
      _Area,
      _Enable);
}

inline const fb::PlaceableItem *GetPlaceableItem(const void *buf) {
  return ::flatbuffers::GetRoot<fb::PlaceableItem>(buf);
}

inline const fb::PlaceableItem *GetSizePrefixedPlaceableItem(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::PlaceableItem>(buf);
}

inline bool VerifyPlaceableItemBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::PlaceableItem>(nullptr);
}

inline bool VerifySizePrefixedPlaceableItemBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::PlaceableItem>(nullptr);
}

inline void FinishPlaceableItemBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::PlaceableItem> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPlaceableItemBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::PlaceableItem> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::PlaceableItemT> UnPackPlaceableItem(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::PlaceableItemT>(GetPlaceableItem(buf)->UnPack(res));
}

inline std::unique_ptr<fb::PlaceableItemT> UnPackSizePrefixedPlaceableItem(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::PlaceableItemT>(GetSizePrefixedPlaceableItem(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_PLACEABLEITEM_FB_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTMAP_FB_H_
#define FLATBUFFERS_GENERATED_TEXTMAP_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace fb {

struct text_map;
struct text_mapBuilder;
struct text_mapT;

struct text_mapRow;
struct text_mapRowBuilder;
struct text_mapRowT;

struct text_mapT : public ::flatbuffers::NativeTable {
  typedef text_map TableType;
  std::vector<std::unique_ptr<fb::text_mapRowT>> text_maps{};
  text_mapT() = default;
  text_mapT(const text_mapT &o);
  text_mapT(text_mapT&&) FLATBUFFERS_NOEXCEPT = default;
  text_mapT &operator=(text_mapT o) FLATBUFFERS_NOEXCEPT;
};

struct text_map FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef text_mapT NativeTableType;
  typedef text_mapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT_MAPS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::text_mapRow>> *text_maps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::text_mapRow>> *>(VT_TEXT_MAPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT_MAPS) &&
           verifier.VerifyVector(text_maps()) &&
           verifier.VerifyVectorOfTables(text_maps()) &&
           verifier.EndTable();
  }
  text_mapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(text_mapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<text_map> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct text_mapBuilder {
  typedef text_map Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text_maps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::text_mapRow>>> text_maps) {
    fbb_.AddOffset(text_map::VT_TEXT_MAPS, text_maps);
  }
  explicit text_mapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<text_map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<text_map>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<text_map> Createtext_map(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::text_mapRow>>> text_maps = 0) {
  text_mapBuilder builder_(_fbb);
  builder_.add_text_maps(text_maps);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<text_map> Createtext_mapDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::text_mapRow>> *text_maps = nullptr) {
  auto text_maps__ = text_maps ? _fbb.CreateVector<::flatbuffers::Offset<fb::text_mapRow>>(*text_maps) : 0;
  return fb::Createtext_map(
      _fbb,
      text_maps__);
}

::flatbuffers::Offset<text_map> Createtext_map(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct text_mapRowT : public ::flatbuffers::NativeTable {
  typedef text_mapRow TableType;
  uint32_t Id = 0;
  std::string Keyword{};
  uint32_t RangeFrom = 0;
  uint32_t RangeLen = 0;
  std::string VersionStart{};
  std::string VersionEnd{};
};

struct text_mapRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef text_mapRowT NativeTableType;
  typedef text_mapRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_KEYWORD = 6,
    VT_RANGEFROM = 8,
    VT_RANGELEN = 10,
    VT_VERSIONSTART = 12,
    VT_VERSIONEND = 14
  };
  uint32_t Id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *Keyword() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEYWORD);
  }
  uint32_t RangeFrom() const {
    return GetField<uint32_t>(VT_RANGEFROM, 0);
  }
  uint32_t RangeLen() const {
    return GetField<uint32_t>(VT_RANGELEN, 0);
  }
  const ::flatbuffers::String *VersionStart() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSIONSTART);
  }
  const ::flatbuffers::String *VersionEnd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSIONEND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_KEYWORD) &&
           verifier.VerifyString(Keyword()) &&
           VerifyField<uint32_t>(verifier, VT_RANGEFROM, 4) &&
           VerifyField<uint32_t>(verifier, VT_RANGELEN, 4) &&
           VerifyOffset(verifier, VT_VERSIONSTART) &&
           verifier.VerifyString(VersionStart()) &&
           VerifyOffset(verifier, VT_VERSIONEND) &&
           verifier.VerifyString(VersionEnd()) &&
           verifier.EndTable();
  }
  text_mapRowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(text_mapRowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<text_mapRow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct text_mapRowBuilder {
  typedef text_mapRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(uint32_t Id) {
    fbb_.AddElement<uint32_t>(text_mapRow::VT_ID, Id, 0);
  }
  void add_Keyword(::flatbuffers::Offset<::flatbuffers::String> Keyword) {
    fbb_.AddOffset(text_mapRow::VT_KEYWORD, Keyword);
  }
  void add_RangeFrom(uint32_t RangeFrom) {
    fbb_.AddElement<uint32_t>(text_mapRow::VT_RANGEFROM, RangeFrom, 0);
  }
  void add_RangeLen(uint32_t RangeLen) {
    fbb_.AddElement<uint32_t>(text_mapRow::VT_RANGELEN, RangeLen, 0);
  }
  void add_VersionStart(::flatbuffers::Offset<::flatbuffers::String> VersionStart) {
    fbb_.AddOffset(text_mapRow::VT_VERSIONSTART, VersionStart);
  }
  void add_VersionEnd(::flatbuffers::Offset<::flatbuffers::String> VersionEnd) {
    fbb_.AddOffset(text_mapRow::VT_VERSIONEND, VersionEnd);
  }
  explicit text_mapRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<text_mapRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<text_mapRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<text_mapRow> Createtext_mapRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Keyword = 0,
    uint32_t RangeFrom = 0,
    uint32_t RangeLen = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VersionStart = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VersionEnd = 0) {
  text_mapRowBuilder builder_(_fbb);
  builder_.add_VersionEnd(VersionEnd);
  builder_.add_VersionStart(VersionStart);
  builder_.add_RangeLen(RangeLen);
  builder_.add_RangeFrom(RangeFrom);
  builder_.add_Keyword(Keyword);
  builder_.add_Id(Id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<text_mapRow> Createtext_mapRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Id = 0,
    const char *Keyword = nullptr,
    uint32_t RangeFrom = 0,
    uint32_t RangeLen = 0,
    const char *VersionStart = nullptr,
    const char *VersionEnd = nullptr) {
  auto Keyword__ = Keyword ? _fbb.CreateString(Keyword) : 0;
  auto VersionStart__ = VersionStart ? _fbb.CreateString(VersionStart) : 0;
  auto VersionEnd__ = VersionEnd ? _fbb.CreateString(VersionEnd) : 0;
  return fb::Createtext_mapRow(
      _fbb,
      Id,
      Keyword__,
      RangeFrom,
      RangeLen,
      VersionStart__,
      VersionEnd__);
}

::flatbuffers::Offset<text_mapRow> Createtext_mapRow(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline text_mapT::text_mapT(const text_mapT &o) {
  text_maps.reserve(o.text_maps.size());
  for (const auto &text_maps_ : o.text_maps) { text_maps.emplace_back((text_maps_) ? new fb::text_mapRowT(*text_maps_) : nullptr); }
}

inline text_mapT &text_mapT::operator=(text_mapT o) FLATBUFFERS_NOEXCEPT {
  std::swap(text_maps, o.text_maps);
  return *this;
}

inline text_mapT *text_map::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<text_mapT>(new text_mapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void text_map::UnPackTo(text_mapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text_maps(); if (_e) { _o->text_maps.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->text_maps[_i]) { _e->Get(_i)->UnPackTo(_o->text_maps[_i].get(), _resolver); } else { _o->text_maps[_i] = std::unique_ptr<fb::text_mapRowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->text_maps.resize(0); } }
}

inline ::flatbuffers::Offset<text_map> text_map::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtext_map(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<text_map> Createtext_map(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const text_mapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text_maps = _o->text_maps.size() ? _fbb.CreateVector<::flatbuffers::Offset<fb::text_mapRow>> (_o->text_maps.size(), [](size_t i, _VectorArgs *__va) { return Createtext_mapRow(*__va->__fbb, __va->__o->text_maps[i].get(), __va->__rehasher); }, &_va ) : 0;
  return fb::Createtext_map(
      _fbb,
      _text_maps);
}

inline text_mapRowT *text_mapRow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<text_mapRowT>(new text_mapRowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void text_mapRow::UnPackTo(text_mapRowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); _o->Id = _e; }
  { auto _e = Keyword(); if (_e) _o->Keyword = _e->str(); }
  { auto _e = RangeFrom(); _o->RangeFrom = _e; }
  { auto _e = RangeLen(); _o->RangeLen = _e; }
  { auto _e = VersionStart(); if (_e) _o->VersionStart = _e->str(); }
  { auto _e = VersionEnd(); if (_e) _o->VersionEnd = _e->str(); }
}

inline ::flatbuffers::Offset<text_mapRow> text_mapRow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapRowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return Createtext_mapRow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<text_mapRow> Createtext_mapRow(::flatbuffers::FlatBufferBuilder &_fbb, const text_mapRowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const text_mapRowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id;
  auto _Keyword = _o->Keyword.empty() ? 0 : _fbb.CreateString(_o->Keyword);
  auto _RangeFrom = _o->RangeFrom;
  auto _RangeLen = _o->RangeLen;
  auto _VersionStart = _o->VersionStart.empty() ? 0 : _fbb.CreateString(_o->VersionStart);
  auto _VersionEnd = _o->VersionEnd.empty() ? 0 : _fbb.CreateString(_o->VersionEnd);
  return fb::Createtext_mapRow(
      _fbb,
      _Id,
      _Keyword,
      _RangeFrom,
      _RangeLen,
      _VersionStart,
      _VersionEnd);
}

inline const fb::text_map *Gettext_map(const void *buf) {
  return ::flatbuffers::GetRoot<fb::text_map>(buf);
}

inline const fb::text_map *GetSizePrefixedtext_map(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fb::text_map>(buf);
}

inline bool Verifytext_mapBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fb::text_map>(nullptr);
}

inline bool VerifySizePrefixedtext_mapBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fb::text_map>(nullptr);
}

inline void Finishtext_mapBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::text_map> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedtext_mapBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fb::text_map> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fb::text_mapT> UnPacktext_map(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::text_mapT>(Gettext_map(buf)->UnPack(res));
}

inline std::unique_ptr<fb::text_mapT> UnPackSizePrefixedtext_map(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fb::text_mapT>(GetSizePrefixedtext_map(buf)->UnPack(res));
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_TEXTMAP_FB_H_
